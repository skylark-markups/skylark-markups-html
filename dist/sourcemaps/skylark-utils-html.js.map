{"version":3,"sources":["skylark-utils-html.js"],"names":["factory","globals","absolute","relative","base","stack","split","parts","pop","i","length","push","join","define","require","isAmd","amd","isCmd","exports","map","id","deps","dep","hasOwnProperty","Error","module","args","forEach","apply","window","skylarkjs","skylark","html","langx","normalizeCssEvent","name","css3EventPrefix","toLowerCase","normalizeCssProperty","cssProps","normalizeStyleProperty","cssStyles","browser","vendorPrefix","vendorPrefixRE","css3PropPrefix","css3StylePrefix","vendorPrefixesRE","document","testEl","createElement","matchesSelector","webkitMatchesSelector","mozMatchesSelector","oMatchesSelector","requestFullScreen","requestFullscreen","webkitRequestFullscreen","mozRequestFullScreen","msRequestFullscreen","testStyle","exitFullscreen","webkitCancelFullScreen","mozCancelFullScreen","msExitFullscreen","style","matched","match","RegExp","lowerFirst","cssPropName","dasherize","mixin","location","support","maybeAddPx","value","cssNumber","classRE","classReCache","className","node","klass","svg","undefined","baseVal","defaultDisplay","nodeName","element","display","elementDisplay","body","appendChild","getComputedStyle","getPropertyValue","parentNode","removeChild","show","elm","styler","css","this","isInvisible","hide","addClass","names","cls","isString","re","property","arguments","computedStyle","camelCase","isArrayLike","props","call","prop","removeProperty","key","cssText","hasClass","removeClass","replace","trim","toggleClass","when","self","Array","prototype","every","column-count","columns","font-weight","line-height","opacity","z-index","zoom","autocssfix","cssHooks","ensureNodes","nodes","copyByClone","cloneNode","flatten","chkName","after","placing","refNode","parent","nextSibling","insertBefore","append","before","contents","contentDocument","childNodes","tag","setAttribute","createFragment","singleTagRE","test","$1","fragmentRE","containers","container","innerHTML","dom","slice","clone","deep","isIE","nodeType","each","getAttribs","attr","setAttrib","getAttrib","contains","child","isChildOf","createTextNode","text","doc","empty","hasChildNodes","firstChild","fullScreen","el","exitFullScreen","fullscreenElement","webkitFullscreenElement","mozFullScreenElement","msFullscreenElement","fulledEl","isNumber","directly","documentElement","isDoc","DOCUMENT_NODE","ownerDoc","ownerDocument","ownerWindow","defaultView","parentWindow","prepend","offsetParent","rootNodeRE","overlay","params","overlayDiv","position","top","left","width","height","zIndex","remove","e","console","warn","oldNode","replaceChild","throb","timer","time","callback","throbber","textNode","clearTimeout","update","nodeValue","end","setTimeout","traverse","fn","len","reverse","children","wrapper","wrapperNode","wrapperInner","unwrap","noder","navigator","userAgent","div","table","tableBody","tableRow","tr","tbody","thead","tfoot","td","th","*","isWindow","_createStyleSheet","external","options","type","count","media","create","rel","async","head","sheetsById","createStyleSheet","sheetId","addSheetRules","deleteSheetRule","rule","sheet","deleteRuleFunc","rulesPropName","_rule","deleteRule","defaultSheetId","removeStyleSheet","insertRule","selector","index","insertSheetRule","addRules","rules","insertRuleFunc","toString","isAtRule","str","startsWith","json","adjust","parentName","depth","strNode","values","atFlg","SPACE","repeat","isArray","n","adjusted","getElementsByTagName","defaultSheet","removeRule","_insertRule","addRule","css_beautify","source_text","next","ch","charAt","pos","peek","skipWhitespace","prev_pos","eatWhitespace","result","eatString","endChars","start","indexOf","substring","peekString","endChar","whiteRe","eatComment","singleLine","lookBack","foundNestedPseudoClass","indent","indentLevel","basebaseIndentString","singleIndent","outdent","indentSize","indent_size","indentCharacter","indent_char","selectorSeparatorNewline","selector_separator_newline","end_with_newline","parseInt","nestedLevel","print","singleSpace","output","newLine","_lastCharWhitespace","keepWhitespace","insideRule","enteringConditionalGroup","top_ch","last_top_ch","whitespace","isAfterSpace","isAfterNewline","header","variableOrRule","NESTED_AT_RULE","CONDITIONAL_GROUP_RULE","sweetCode","@page","@font-face","@keyframes","@media","@supports","@document","beautifyCss","beautify","velm","createInputPseudo","elem","createButtonPseudo","ancestor","root","rootIsSelector","matches","ancestors","ret","local","filter","byId","getElementById","closest","descendants","querySelectorAll","matchError","query","descendant","querySelector","find","findAll","first","lastChild","last","previousSibling","nativeMatchesSelector","inArray","isPlainObject","check","adjacent","nextSiblings","previousSiblings","siblings","parser","rawMatch","separator","combinator","combinatorChildren","tagName","attributeKey","attributeOperator","attributeQuote","attributeValue","pseudoMarker","pseudoClass","pseudoQuote","pseudoClassQuotedValue","pseudoClassValue","separatorIndex","parsed","expressions","combinatorIndex","currentSeparator","reversed","reverseCombinator","currentParsed","reUnescape","classList","classes","regexp","escapeRegExp","pseudos","attributes","operator","cache","reverseCache","parse","expression","isReversed","Slick","currentCache","raw","exp","j","cexp","from","to","string","rinputs","rheader","parseSelector","button","checked","idx","$","disabled","enabled","eq","even","focus","activeElement","href","tabindex","gt","has","sel","hidden","input","lt","not","odd","selected","visible","offsetWidth","item","isArrayFilter","radio","checkbox","file","password","image","submit","reset","divide","cond","nativeSelector","customPseudos","JSON","stringify","part","toUpperCase","arrayFilte","pseudo","getAttribute","hasAttribute","currentExpression","simpleExpCounter","filterSingle","matchs","uniq","concat","combine","bit","node1","op","prev","divided","single","currentBit","founds","found","currentItems","finder","scripter","scriptsByUrl","scriptElementsById","loadJavaScript","url","loadedCallback","errorCallback","script","state","loadedCallbacks","errorCallbacks","onload","onerror","defer","startTime","Date","getTime","callbacks","src","deleteJavaScript","in_array","what","arr","s","js_beautify","js_source_text","beautifier","Beautifier","create_flags","flags_base","mode","next_indent_level","indentation_level","just_added_newline","line_indent_level","next_flags","last_text","last_word","declaration_statement","declaration_assignment","multiline_frame","if_block","else_block","do_block","do_while","in_case_statement","in_case","case_body","start_line_index","get_line_number","ternary_depth","handle_token","local_token","newlines","keep_whitespace","opt","keep_array_indentation","is_array","flags","print_newline","max_preserve_newlines","preserve_newlines","current_token","handlers","split_newlines","out","allow_wrap_or_preserved_newline","force_linewrap","wanted_newline","wrap_line_length","proposed_line_length","current_line","get_character_count","space_before_token","force_newline","preserve_statement_flags","last_type","MODE","Statement","restore_mode","add_new_line","print_token_line_indentation","whitespace_before","set_indent","print_token","printable_token","add_token","deindent","set_mode","flag_store","previous_flags","ArrayLiteral","is_expression","Expression","ForInitializer","Conditional","remove_redundant_indentation","start_of_object_property","ObjectLiteral","start_of_statement","BlockStatement","all_lines_start_with","lines","c","line","each_line_matches_indent","is_special_word","word","get_token","offset","token_pos","tokens","handle_start_expr","next_mode","Tokenizer","line_starters","space_in_paren","last_last_text","space_after_anon_function","space_before_conditional","handle_end_expr","space_in_empty_paren","handle_start_block","next_token","second_token","empty_braces","comments_before","empty_anonymous_function","brace_style","handle_end_block","handle_word","jslint_happy","just_added_blankline","prefix","handle_semicolon","handle_string","handle_equals","handle_comma","handle_operator","space_before","space_after","handle_block_comment","javadoc","starless","lastIndent","lastIndentLength","handle_inline_comment","handle_comment","handle_dot","break_chained_methods","handle_unknown","handle_eof","indent_string","baseIndentString","TK_START_EXPR","TK_END_EXPR","TK_START_BLOCK","TK_END_BLOCK","TK_WORD","TK_RESERVED","TK_SEMICOLON","TK_STRING","TK_EQUALS","TK_OPERATOR","TK_COMMA","TK_BLOCK_COMMENT","TK_INLINE_COMMENT","TK_COMMENT","TK_DOT","TK_UNKNOWN","TK_EOF","braces_on_own_line","unescape_strings","e4x","indent_with_tabs","preindent_index","Output","sweet_code","tokenizer","tokenize","get_code","OutputLine","_character_count","_indent_count","_items","_empty","level","baseIndentLength","indent_length","is_empty","remove_indent","indent_cache","add_space_before_token","frame","output_length","eat_newlines","opts","tokenize_next","resulting_string","whitespace_on_this_line","n_newlines","whitespace_before_token","parser_pos","input_length","last_token","Token","digit","allow_decimal","allow_e","local_digit","acorn","isIdentifierStart","charCodeAt","isIdentifierChar","reserved_words","comment","inline_comment","sep","esc","has_char_escapes","in_char_class","newline","xmlRegExp","xmlStr","exec","rootTag","isEndTag","isSingletonTag","xmlLength","unescape_string","sharp","in_html_comment","punct","s_hex","escaped","substr","String","fromCharCode","token_values","open","open_stack","comments","nonASCIIidentifierStartChars","nonASCIIidentifierChars","nonASCIIidentifierStart","nonASCIIidentifier","code","js","beautifyJs","beautifyHtml","ltrim","rtrim","style_html","html_source","Parser","token","current_mode","tags","parentcount","parent1","tag_type","token_text","token_type","indent_content","indent_inner_html","Utils","single_token","extra_liners","is_whitespace","traverse_whitespace","input_char","space_or_wrap","content","line_char_count","print_indentation","get_content","indent_handlebars","peek3","get_tag","get_contents_to","reg_match","lastIndex","reg_array","end_script","record_tag","indent_level","retrieve_tag","temp_parent","indent_to_tag","tag_start","tag_end","tag_start_char","space","orig_pos","orig_line_char_count","get_unformatted","get_comment","tag_index","tag_offset","tag_complete","tag_check","is_unformatted","unformatted","search","start_pos","delimiter","orig_tag","min_index","tag_name_type","get_full_indent","next_tag","printer","js_source","indent_character","force","print_token_raw","unindent","multi_parser","max_char","isNaN","t","tag_name","tag_extracted_from_last_output","_beautifier","script_indent_level","indent_scripts","indentation","white","_level","reindent","html_beautify","main"],"mappings":"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","file":"../skylark-utils-html.js","sourcesContent":["define('skylark-utils/skylark',[\"skylark-langx/skylark\"], function(skylark) {\r\n    return skylark;\r\n});\r\n\ndefine('skylark-utils-html/html',[\r\n    \"skylark-utils/skylark\"\r\n], function(skylark) {\r\n\treturn skylark.html = skylark.html || {};\r\n});\ndefine('skylark-utils/langx',[\r\n    \"skylark-langx/langx\"\r\n], function(langx) {\r\n    return langx;\r\n});\r\n\ndefine('skylark-utils/browser',[\r\n    \"./skylark\",\r\n    \"./langx\"\r\n], function(skylark,langx) {\r\n    var checkedCssProperties = {\r\n        \"transitionproperty\": \"TransitionProperty\",\r\n    };\r\n\r\n    var css3PropPrefix = \"\",\r\n        css3StylePrefix = \"\",\r\n        css3EventPrefix = \"\",\r\n\r\n        cssStyles = {},\r\n        cssProps = {},\r\n\r\n        vendorPrefix,\r\n        vendorPrefixRE,\r\n        vendorPrefixesRE = /^(Webkit|webkit|O|Moz|moz|ms)(.*)$/,\r\n\r\n        document = window.document,\r\n        testEl = document.createElement(\"div\"),\r\n\r\n        matchesSelector = testEl.webkitMatchesSelector ||\r\n                          testEl.mozMatchesSelector ||\r\n                          testEl.oMatchesSelector ||\r\n                          testEl.matchesSelector,\r\n\r\n        requestFullScreen = testEl.requestFullscreen || \r\n                            testEl.webkitRequestFullscreen || \r\n                            testEl.mozRequestFullScreen || \r\n                            testEl.msRequestFullscreen,\r\n\r\n        exitFullScreen =  document.exitFullscreen ||\r\n                          document.webkitCancelFullScreen ||\r\n                          document.mozCancelFullScreen ||\r\n                          document.msExitFullscreen,\r\n\r\n        testStyle = testEl.style;\r\n\r\n    for (var name in testStyle) {\r\n        var matched = name.match(vendorPrefixRE || vendorPrefixesRE);\r\n        if (matched) {\r\n            if (!vendorPrefixRE) {\r\n                vendorPrefix = matched[1];\r\n                vendorPrefixRE = new RegExp(\"^(\" + vendorPrefix + \")(.*)$\");\r\n\r\n                css3StylePrefix = vendorPrefix;\r\n                css3PropPrefix = '-' + vendorPrefix.toLowerCase() + '-';\r\n                css3EventPrefix = vendorPrefix.toLowerCase();\r\n            }\r\n\r\n            cssStyles[langx.lowerFirst(matched[2])] = name;\r\n            var cssPropName = langx.dasherize(matched[2]);\r\n            cssProps[cssPropName] = css3PropPrefix + cssPropName;\r\n\r\n        }\r\n    }\r\n\r\n\r\n    function normalizeCssEvent(name) {\r\n        return css3EventPrefix ? css3EventPrefix + name : name.toLowerCase();\r\n    }\r\n\r\n    function normalizeCssProperty(name) {\r\n        return cssProps[name] || name;\r\n    }\r\n\r\n    function normalizeStyleProperty(name) {\r\n        return cssStyles[name] || name;\r\n    }\r\n\r\n    function browser() {\r\n        return browser;\r\n    }\r\n\r\n    langx.mixin(browser, {\r\n        css3PropPrefix: css3PropPrefix,\r\n\r\n        normalizeStyleProperty: normalizeStyleProperty,\r\n\r\n        normalizeCssProperty: normalizeCssProperty,\r\n\r\n        normalizeCssEvent: normalizeCssEvent,\r\n\r\n        matchesSelector: matchesSelector,\r\n\r\n        requestFullScreen : requestFullScreen,\r\n\r\n        exitFullscreen : requestFullScreen,\r\n\r\n        location: function() {\r\n            return window.location;\r\n        },\r\n\r\n        support : {\r\n\r\n        }\r\n\r\n    });\r\n\r\n    testEl = null;\r\n\r\n    return skylark.browser = browser;\r\n});\r\n\ndefine('skylark-utils/styler',[\r\n    \"./skylark\",\r\n    \"./langx\"\r\n], function(skylark, langx) {\r\n    var every = Array.prototype.every,\r\n        forEach = Array.prototype.forEach,\r\n        camelCase = langx.camelCase,\r\n        dasherize = langx.dasherize;\r\n\r\n    function maybeAddPx(name, value) {\r\n        return (typeof value == \"number\" && !cssNumber[dasherize(name)]) ? value + \"px\" : value\r\n    }\r\n\r\n    var cssNumber = {\r\n            'column-count': 1,\r\n            'columns': 1,\r\n            'font-weight': 1,\r\n            'line-height': 1,\r\n            'opacity': 1,\r\n            'z-index': 1,\r\n            'zoom': 1\r\n        },\r\n        classReCache = {\r\n\r\n        };\r\n\r\n    function classRE(name) {\r\n        return name in classReCache ?\r\n            classReCache[name] : (classReCache[name] = new RegExp('(^|\\\\s)' + name + '(\\\\s|$)'));\r\n    }\r\n\r\n    // access className property while respecting SVGAnimatedString\r\n    function className(node, value) {\r\n        var klass = node.className || '',\r\n            svg = klass && klass.baseVal !== undefined\r\n\r\n        if (value === undefined) return svg ? klass.baseVal : klass\r\n        svg ? (klass.baseVal = value) : (node.className = value)\r\n    }\r\n\r\n\r\n    var elementDisplay = {};\r\n\r\n    function defaultDisplay(nodeName) {\r\n        var element, display\r\n        if (!elementDisplay[nodeName]) {\r\n            element = document.createElement(nodeName)\r\n            document.body.appendChild(element)\r\n            display = getComputedStyle(element, '').getPropertyValue(\"display\")\r\n            element.parentNode.removeChild(element)\r\n            display == \"none\" && (display = \"block\")\r\n            elementDisplay[nodeName] = display\r\n        }\r\n        return elementDisplay[nodeName]\r\n    }\r\n\r\n    function show(elm) {\r\n        styler.css(elm, \"display\", \"\");\r\n        if (styler.css(elm, \"display\") == \"none\") {\r\n            styler.css(elm, \"display\", defaultDisplay(elm.nodeName));\r\n        }\r\n        return this;\r\n    }\r\n\r\n    function isInvisible(elm) {\r\n        return styler.css(elm, \"display\") == \"none\" || styler.css(elm, \"opacity\") == 0;\r\n    }\r\n\r\n    function hide(elm) {\r\n        styler.css(elm, \"display\", \"none\");\r\n        return this;\r\n    }\r\n\r\n    function addClass(elm, name) {\r\n        if (!name) return this\r\n        var cls = className(elm),\r\n            names;\r\n        if (langx.isString(name)) {\r\n            names = name.split(/\\s+/g);\r\n        } else {\r\n            names = name;\r\n        }\r\n        names.forEach(function(klass) {\r\n            var re = classRE(klass);\r\n            if (!cls.match(re)) {\r\n                cls += (cls ? \" \" : \"\") + klass;\r\n            }\r\n        });\r\n\r\n        className(elm, cls);\r\n\r\n        return this;\r\n    }\r\n\r\n    function css(elm, property, value) {\r\n        if (arguments.length < 3) {\r\n            var computedStyle,\r\n                computedStyle = getComputedStyle(elm, '')\r\n            if (langx.isString(property)) {\r\n                return elm.style[camelCase(property)] || computedStyle.getPropertyValue(property)\r\n            } else if (langx.isArrayLike(property)) {\r\n                var props = {}\r\n                forEach.call(property, function(prop) {\r\n                    props[prop] = (elm.style[camelCase(prop)] || computedStyle.getPropertyValue(prop))\r\n                })\r\n                return props\r\n            }\r\n        }\r\n\r\n        var css = '';\r\n        if (typeof(property) == 'string') {\r\n            if (!value && value !== 0) {\r\n                elm.style.removeProperty(dasherize(property));\r\n            } else {\r\n                css = dasherize(property) + \":\" + maybeAddPx(property, value)\r\n            }\r\n        } else {\r\n            for (key in property) {\r\n                if (property[key] === undefined) {\r\n                    continue;\r\n                }\r\n                if (!property[key] && property[key] !== 0) {\r\n                    elm.style.removeProperty(dasherize(key));\r\n                } else {\r\n                    css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';'\r\n                }\r\n            }\r\n        }\r\n\r\n        elm.style.cssText += ';' + css;\r\n        return this;\r\n    }\r\n\r\n\r\n    function hasClass(elm, name) {\r\n        var re = classRE(name);\r\n        return elm.className && elm.className.match(re);\r\n    }\r\n\r\n    function removeClass(elm, name) {\r\n        if (name) {\r\n            var cls = className(elm),\r\n                names;\r\n\r\n            if (langx.isString(name)) {\r\n                names = name.split(/\\s+/g);\r\n            } else {\r\n                names = name;\r\n            }\r\n\r\n            names.forEach(function(klass) {\r\n                var re = classRE(klass);\r\n                if (cls.match(re)) {\r\n                    cls = cls.replace(re, \" \");\r\n                }\r\n            });\r\n\r\n            className(elm, cls.trim());\r\n        } else {\r\n            className(elm,\"\");\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    function toggleClass(elm, name, when) {\r\n        var self = this;\r\n        name.split(/\\s+/g).forEach(function(klass) {\r\n            if (when === undefined) {\r\n                when = !self.hasClass(elm, klass);\r\n            }\r\n            if (when) {\r\n                self.addClass(elm, klass);\r\n            } else {\r\n                self.removeClass(elm, klass)\r\n            }\r\n        });\r\n\r\n        return self;\r\n    }\r\n\r\n    var styler = function() {\r\n        return styler;\r\n    };\r\n\r\n    langx.mixin(styler, {\r\n        autocssfix: false,\r\n        cssHooks : {\r\n\r\n        },\r\n        \r\n        addClass: addClass,\r\n        className: className,\r\n        css: css,\r\n        hasClass: hasClass,\r\n        hide: hide,\r\n        isInvisible: isInvisible,\r\n        removeClass: removeClass,\r\n        show: show,\r\n        toggleClass: toggleClass\r\n    });\r\n\r\n    return skylark.styler = styler;\r\n});\r\n\ndefine('skylark-utils/noder',[\r\n    \"./skylark\",\r\n    \"./langx\",\r\n    \"./browser\",\r\n    \"./styler\"\r\n], function(skylark, langx, browser, styler) {\r\n    var isIE = !!navigator.userAgent.match(/Trident/g) || !!navigator.userAgent.match(/MSIE/g),\r\n        fragmentRE = /^\\s*<(\\w+|!)[^>]*>/,\r\n        singleTagRE = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\r\n        div = document.createElement(\"div\"),\r\n        table = document.createElement('table'),\r\n        tableBody = document.createElement('tbody'),\r\n        tableRow = document.createElement('tr'),\r\n        containers = {\r\n            'tr': tableBody,\r\n            'tbody': table,\r\n            'thead': table,\r\n            'tfoot': table,\r\n            'td': tableRow,\r\n            'th': tableRow,\r\n            '*': div\r\n        },\r\n        rootNodeRE = /^(?:body|html)$/i,\r\n        map = Array.prototype.map,\r\n        slice = Array.prototype.slice;\r\n\r\n    function ensureNodes(nodes, copyByClone) {\r\n        if (!langx.isArrayLike(nodes)) {\r\n            nodes = [nodes];\r\n        }\r\n        if (copyByClone) {\r\n            nodes = map.call(nodes, function(node) {\r\n                return node.cloneNode(true);\r\n            });\r\n        }\r\n        return langx.flatten(nodes);\r\n    }\r\n\r\n    function nodeName(elm, chkName) {\r\n        var name = elm.nodeName && elm.nodeName.toLowerCase();\r\n        if (chkName !== undefined) {\r\n            return name === chkName.toLowerCase();\r\n        }\r\n        return name;\r\n    };\r\n\r\n    function after(node, placing, copyByClone) {\r\n        var refNode = node,\r\n            parent = refNode.parentNode;\r\n        if (parent) {\r\n            var nodes = ensureNodes(placing, copyByClone),\r\n                refNode = refNode.nextSibling;\r\n\r\n            for (var i = 0; i < nodes.length; i++) {\r\n                if (refNode) {\r\n                    parent.insertBefore(nodes[i], refNode);\r\n                } else {\r\n                    parent.appendChild(nodes[i]);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    function append(node, placing, copyByClone) {\r\n        var parentNode = node,\r\n            nodes = ensureNodes(placing, copyByClone);\r\n        for (var i = 0; i < nodes.length; i++) {\r\n            parentNode.appendChild(nodes[i]);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    function before(node, placing, copyByClone) {\r\n        var refNode = node,\r\n            parent = refNode.parentNode;\r\n        if (parent) {\r\n            var nodes = ensureNodes(placing, copyByClone);\r\n            for (var i = 0; i < nodes.length; i++) {\r\n                parent.insertBefore(nodes[i], refNode);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    function contents(elm) {\r\n        if (nodeName(elm, \"iframe\")) {\r\n            return elm.contentDocument;\r\n        }\r\n        return elm.childNodes;\r\n    }\r\n\r\n    function createElement(tag, props,parent) {\r\n        var node = document.createElement(tag);\r\n        if (props) {\r\n            for (var name in props) {\r\n                node.setAttribute(name, props[name]);\r\n            }\r\n        }\r\n        if (parent) {\r\n            append(parent,node);\r\n        }\r\n        return node;\r\n    }\r\n\r\n    function createFragment(html) {\r\n        // A special case optimization for a single tag\r\n        html = langx.trim(html);\r\n        if (singleTagRE.test(html)) {\r\n            return [createElement(RegExp.$1)];\r\n        }\r\n\r\n        var name = fragmentRE.test(html) && RegExp.$1\r\n        if (!(name in containers)) {\r\n            name = \"*\"\r\n        }\r\n        var container = containers[name];\r\n        container.innerHTML = \"\" + html;\r\n        dom = slice.call(container.childNodes);\r\n\r\n        dom.forEach(function(node) {\r\n            container.removeChild(node);\r\n        })\r\n\r\n        return dom;\r\n    }\r\n\r\n    function clone(node, deep) {\r\n        var self = this,\r\n            clone;\r\n\r\n        // TODO: Add feature detection here in the future\r\n        if (!isIE || node.nodeType !== 1 || deep) {\r\n            return node.cloneNode(deep);\r\n        }\r\n\r\n        // Make a HTML5 safe shallow copy\r\n        if (!deep) {\r\n            clone = document.createElement(node.nodeName);\r\n\r\n            // Copy attribs\r\n            each(self.getAttribs(node), function(attr) {\r\n                self.setAttrib(clone, attr.nodeName, self.getAttrib(node, attr.nodeName));\r\n            });\r\n\r\n            return clone;\r\n        }\r\n    }\r\n\r\n    function contains(node, child) {\r\n        return isChildOf(child, node);\r\n    }\r\n\r\n    function createTextNode(text) {\r\n        return document.createTextNode(text);\r\n    }\r\n\r\n    function doc() {\r\n        return document;\r\n    }\r\n\r\n    function empty(node) {\r\n        while (node.hasChildNodes()) {\r\n            var child = node.firstChild;\r\n            node.removeChild(child);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    var fulledEl = null;\r\n    function fullScreen(el) {\r\n        if (el === false) {\r\n            browser.exitFullScreen.apply(document);\r\n        } else if (el) {\r\n            browser.requestFullScreen.apply(el);\r\n            fulledEl = el;\r\n        } else {\r\n          return (\r\n            document.fullscreenElement ||\r\n            document.webkitFullscreenElement ||\r\n            document.mozFullScreenElement ||\r\n            document.msFullscreenElement\r\n          )\r\n        }\r\n    }\r\n\r\n    function html(node, html) {\r\n        if (html === undefined) {\r\n            return node.innerHTML;\r\n        } else {\r\n            this.empty(node);\r\n            html = html || \"\";\r\n            if (langx.isString(html) || langx.isNumber(html)) {\r\n                node.innerHTML = html;\r\n            } else if (langx.isArrayLike(html)) {\r\n                for (var i = 0; i < html.length; i++) {\r\n                    node.appendChild(html[i]);\r\n                }\r\n            } else {\r\n                node.appendChild(html);\r\n            }\r\n        }\r\n    }\r\n\r\n    function isChildOf(node, parent,directly) {\r\n        if (directly) {\r\n            return node.parentNode === parent;\r\n        }\r\n        if (document.documentElement.contains) {\r\n            return parent.contains(node);\r\n        }\r\n        while (node) {\r\n            if (parent === node) {\r\n                return true;\r\n            }\r\n\r\n            node = node.parentNode;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function isDoc(node) {\r\n        return node != null && node.nodeType == node.DOCUMENT_NODE\r\n    }\r\n\r\n    function ownerDoc(elm) {\r\n        if (!elm) {\r\n            return document;\r\n        }\r\n\r\n        if (elm.nodeType == 9) {\r\n            return elm;\r\n        }\r\n\r\n        return elm.ownerDocument;\r\n    }\r\n\r\n    function ownerWindow(elm) {\r\n        var doc = ownerDoc(elm);\r\n        return  doc.defaultView || doc.parentWindow;\r\n    } \r\n\r\n\r\n    function prepend(node, placing, copyByClone) {\r\n        var parentNode = node,\r\n            refNode = parentNode.firstChild,\r\n            nodes = ensureNodes(placing, copyByClone);\r\n        for (var i = 0; i < nodes.length; i++) {\r\n            if (refNode) {\r\n                parentNode.insertBefore(nodes[i], refNode);\r\n            } else {\r\n                parentNode.appendChild(nodes[i]);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n\r\n    function offsetParent(elm) {\r\n        var parent = elm.offsetParent || document.body;\r\n        while (parent && !rootNodeRE.test(parent.nodeName) && styler.css(parent, \"position\") == \"static\") {\r\n            parent = parent.offsetParent;\r\n        }\r\n        return parent;\r\n    }\r\n\r\n    function overlay(elm, params) {\r\n        var overlayDiv = createElement(\"div\", params);\r\n        styler.css(overlayDiv, {\r\n            position: \"absolute\",\r\n            top: 0,\r\n            left: 0,\r\n            width: \"100%\",\r\n            height: \"100%\",\r\n            zIndex: 0x7FFFFFFF,\r\n            opacity: 0.7\r\n        });\r\n        elm.appendChild(overlayDiv);\r\n        return overlayDiv;\r\n\r\n    }\r\n\r\n\r\n\r\n    function remove(node) {\r\n        if (node && node.parentNode) {\r\n            try {\r\n               node.parentNode.removeChild(node);\r\n            } catch (e) {\r\n                console.warn(\"The node is already removed\",e);\r\n            }\r\n         }\r\n        return this;\r\n    }\r\n\r\n    function replace(node, oldNode) {\r\n        oldNode.parentNode.replaceChild(node, oldNode);\r\n        return this;\r\n    }\r\n\r\n    function throb(elm, params) {\r\n        params = params || {};\r\n        var self = this,\r\n            text = params.text,\r\n            style = params.style,\r\n            time = params.time,\r\n            callback = params.callback,\r\n            timer,\r\n            throbber = this.createElement(\"div\", {\r\n                className: params.className || \"throbber\",\r\n                style: style\r\n            }),\r\n            _overlay = overlay(throbber, {\r\n                className: 'overlay fade'\r\n            }),\r\n            throb = this.createElement(\"div\", {\r\n                className: \"throb\"\r\n            }),\r\n            textNode = this.createTextNode(text || \"\"),\r\n            remove = function() {\r\n                if (timer) {\r\n                    clearTimeout(timer);\r\n                    timer = null;\r\n                }\r\n                if (throbber) {\r\n                    self.remove(throbber);\r\n                    throbber = null;\r\n                }\r\n            },\r\n            update = function(params) {\r\n                if (params && params.text && throbber) {\r\n                    textNode.nodeValue = params.text;\r\n                }\r\n            };\r\n        throb.appendChild(textNode);\r\n        throbber.appendChild(throb);\r\n        elm.appendChild(throbber);\r\n        var end = function() {\r\n            remove();\r\n            if (callback) callback();\r\n        };\r\n        if (time) {\r\n            timer = setTimeout(end, time);\r\n        }\r\n\r\n        return {\r\n            remove: remove,\r\n            update: update\r\n        };\r\n    }\r\n\r\n    function traverse(node, fn) {\r\n        fn(node)\r\n        for (var i = 0, len = node.childNodes.length; i < len; i++) {\r\n            traverse(node.childNodes[i], fn);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    function reverse(node) {\r\n        var firstChild = node.firstChild;\r\n        for (var i = node.children.length - 1; i > 0; i--) {\r\n            if (i > 0) {\r\n                var child = node.children[i];\r\n                node.insertBefore(child, firstChild);\r\n            }\r\n        }\r\n    }\r\n\r\n    function wrapper(node, wrapperNode) {\r\n        if (langx.isString(wrapperNode)) {\r\n            wrapperNode = this.createFragment(wrapperNode).firstChild;\r\n        }\r\n        node.parentNode.insertBefore(wrapperNode, node);\r\n        wrapperNode.appendChild(node);\r\n    }\r\n\r\n    function wrapperInner(node, wrapperNode) {\r\n        var childNodes = slice.call(node.childNodes);\r\n        node.appendChild(wrapperNode);\r\n        for (var i = 0; i < childNodes.length; i++) {\r\n            wrapperNode.appendChild(childNodes[i]);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    function unwrap(node) {\r\n        var child, parent = node.parentNode;\r\n        if (parent) {\r\n            if (this.isDoc(parent.parentNode)) return;\r\n            parent.parentNode.insertBefore(node, parent);\r\n        }\r\n    }\r\n\r\n    function noder() {\r\n        return noder;\r\n    }\r\n\r\n    langx.mixin(noder, {\r\n        body : function() {\r\n            return document.body;\r\n        },\r\n\r\n        clone: clone,\r\n        contents: contents,\r\n\r\n        createElement: createElement,\r\n\r\n        createFragment: createFragment,\r\n\r\n        contains: contains,\r\n\r\n        createTextNode: createTextNode,\r\n\r\n        doc: doc,\r\n\r\n        empty: empty,\r\n\r\n        fullScreen : fullScreen,\r\n\r\n        html: html,\r\n\r\n        isChildOf: isChildOf,\r\n\r\n        isDoc: isDoc,\r\n\r\n        isWindow : langx.isWindow,\r\n\r\n        offsetParent : offsetParent,\r\n        \r\n        ownerDoc: ownerDoc,\r\n\r\n        ownerWindow : ownerWindow,\r\n\r\n        after: after,\r\n\r\n        before: before,\r\n\r\n        prepend: prepend,\r\n\r\n        append: append,\r\n\r\n        remove: remove,\r\n\r\n        replace: replace,\r\n\r\n        throb: throb,\r\n\r\n        traverse: traverse,\r\n\r\n        reverse: reverse,\r\n\r\n        wrapper: wrapper,\r\n\r\n        wrapperInner: wrapperInner,\r\n\r\n        unwrap: unwrap\r\n    });\r\n\r\n    return skylark.noder = noder;\r\n});\r\n\ndefine('skylark-utils/css',[\r\n    \"./skylark\",\r\n    \"./langx\",\r\n    \"./noder\"\r\n], function(skylark, langx, noder) {\r\n\r\n    var head = document.getElementsByTagName(\"head\")[0],\r\n        count = 0,\r\n        sheetsByUrl = {},\r\n        sheetsById = {},\r\n        defaultSheetId = _createStyleSheet(),\r\n        defaultSheet = sheetsById[defaultSheetId],\r\n        rulesPropName = (\"cssRules\" in defaultSheet) ? \"cssRules\" : \"rules\",\r\n        insertRuleFunc,\r\n        deleteRuleFunc = defaultSheet.deleteRule || defaultSheet.removeRule;\r\n\r\n    if (defaultSheet.insertRule) {\r\n        var _insertRule = defaultSheet.insertRule;\r\n        insertRuleFunc = function(selector, css, index) {\r\n            _insertRule.call(this, selector + \"{\" + css + \"}\", index);\r\n        };\r\n    } else {\r\n        insertRuleFunc = defaultSheet.addRule;\r\n    }\r\n\r\n    function normalizeSelector(selectorText) {\r\n        var selector = [],\r\n            last, len;\r\n        last = defaultSheet[rulesPropName].length;\r\n        insertRuleFunc.call(defaultSheet, selectorText, ';');\r\n        len = defaultSheet[rulesPropName].length;\r\n        for (var i = len - 1; i >= last; i--) {\r\n            selector.push(_sheet[_rules][i].selectorText);\r\n            deleteRuleFunc.call(defaultSheet, i);\r\n        }\r\n        return selector.reverse().join(', ');\r\n    }\r\n\r\n    /*\r\n     * create a stylesheet element.\r\n     * @param {Boolean} external\r\n     * @param {Object} options\r\n     * @param {String} [options.media = null]\r\n     */\r\n    function _createStyleSheet(external,options ) {\r\n        var node,\r\n            props = {\r\n                type : \"text/css\"\r\n            },\r\n            id = (count++);\r\n\r\n        options = options || {};\r\n        if (options.media) {\r\n            props.media = options.media;\r\n        }\r\n\r\n        if (external) {\r\n            node = noder.create(\"link\",langx.mixin(props,{\r\n                rel  : \"stylesheet\",\r\n                async : false\r\n            }));\r\n        } else {\r\n            node = noder.createElement(\"style\",props);\r\n        }\r\n\r\n        noder.append(head,node);\r\n        sheetsById[id] = {\r\n            id : id,\r\n            node :node\r\n        };\r\n\r\n        return id;\r\n    }\r\n\r\n    function createStyleSheet(css,options) {\r\n        if (!options) {\r\n            options = {};\r\n        }\r\n        var sheetId = _createStyleSheet(false,options);\r\n        if (css) {\r\n            addSheetRules(sheetId,css);\r\n        }\r\n\r\n        return sheetId;\r\n    }\r\n\r\n    function loadStyleSheet(url, options) {\r\n        var sheet = sheetsByUrl[url];\r\n        if (!sheet) {\r\n            var sheetId = _createStyleSheet(true,options);\r\n\r\n            sheet = sheetsByUrl[url] = sheetsById[sheetId];\r\n            langx.mixin(sheet,{\r\n                state: 0, //0:unload,1:loaded,-1:loaderror\r\n                url : url,\r\n                deferred : new langx.Deferred()\r\n            });\r\n\r\n            var node = sheet.node;\r\n\r\n            startTime = new Date().getTime();\r\n\r\n            node.onload = function() {\r\n                sheet.state = 1;\r\n                sheet.deferred.resolve(sheet.id);\r\n            },\r\n            node.onerror = function(e) {\r\n                sheet.state = -1;\r\n                sheet.deferred.reject(e);\r\n            };\r\n\r\n            node.href = sheet.url;\r\n        }\r\n        return sheet.deferred.promise;\r\n    }\r\n\r\n    function deleteSheetRule(sheetId, rule) {\r\n        var sheet = sheetsById[sheetId];\r\n        if (langx.isNumber(rule)) {\r\n            deleteRuleFunc.call(sheet, rule);\r\n        } else {\r\n            langx.each(sheet[rulesPropName], function(i, _rule) {\r\n                if (rule === _rule) {\r\n                    deleteRuleFunc.call(sheet, i);\r\n                    return false;\r\n                }\r\n            });\r\n        }\r\n        return this;\r\n    }\r\n\r\n    function deleteRule(rule) {\r\n        deleteSheetRule(defaultSheetId, rule);\r\n        return this;\r\n    }\r\n\r\n    function removeStyleSheet(sheetId) {\r\n        if (sheetId === defaultSheetId) {\r\n            throw new Error(\"The default stylesheet can not be deleted\");\r\n        }\r\n        var sheet = sheetsById[sheetId];\r\n        delete sheetsById[sheetId];\r\n\r\n        noder.remove(sheet.node);\r\n        return this;\r\n    }\r\n\r\n    /*\r\n     * insert a rule to the default stylesheet.\r\n     * @param {String} selector\r\n     * @param {String} css\r\n     * @param {Number} index \r\n     */\r\n    function insertRule(selector, css, index) {\r\n        return this.insertSheetRule(defaultSheetId, selector, css, index);\r\n    }\r\n\r\n    /*\r\n     * Add rules to the default stylesheet.\r\n     * @param {Object} rules\r\n     */\r\n    function addRules(rules) {\r\n        return this.addRules(defaultSheetId,rules);\r\n    }\r\n\r\n    /*\r\n     * insert a rule to the stylesheet specified by sheetId.\r\n     * @param {Number} sheetId  \r\n     * @param {String} selector\r\n     * @param {String} css\r\n     * @param {Number} index \r\n     */\r\n    function insertSheetRule(sheetId, selector, css, index) {\r\n        if (!selector || !css) {\r\n            return -1;\r\n        }\r\n\r\n        var sheet = sheetsById[sheetId];\r\n        index = index || sheet[rulesPropName].length;\r\n\r\n        return insertRuleFunc.call(sheet, selector, css, index);\r\n    }\r\n\r\n    /*\r\n     * Add  rules to stylesheet.\r\n     * @param {Number} sheetId  \r\n     * @param {Object|String} rules\r\n     * @return this\r\n     * @example insertSheetRules(sheetId,{\r\n     * \r\n     * });\r\n     */\r\n    function addSheetRules(sheetId,rules) {\r\n        var sheet = sheetsById[sheetId],\r\n            css;\r\n        if (langx.isString(rules)) {\r\n            css = rules;\r\n        } else {\r\n            css = toString(rules);\r\n        }\r\n\r\n        noder.append(sheet.node,noder.createTextNode(css));\r\n        \r\n        return this;\r\n    }\r\n\r\n    function isAtRule(str) {\r\n        return str.startsWith(\"@\");\r\n    }\r\n\r\n    function toString(json){\r\n        var adjust = function(parentName,name,depth) {\r\n            if (parentName) {\r\n                if (isAtRule(parentName)) {\r\n                    depth += 1;\r\n                } else {\r\n                    name =  parentName + \" \" + name;\r\n                }                \r\n            }\r\n            return {\r\n                name : name,\r\n                depth : depth\r\n            }\r\n        };\r\n\r\n        var strNode = function (name, values, depth) {\r\n            var str = \"\",\r\n                atFlg = isAtRule(name);\r\n\r\n\r\n            if (isAtRule(name)) {\r\n                // at rule\r\n                if (langx.isString(values)) {\r\n                    // an at rule without block\r\n                    // ex: (1) @charset 'utf8';\r\n                    str = css.SPACE.repeat(depth) + name.trim() + \" \\\"\" + values.trim() + \" \\\";\\n\";\r\n                } else {\r\n                    // an at rule with block, ex :\r\n                    //  @media 'screen' {\r\n                    //  }\r\n                    str += css.SPACE.repeat(depth) + name.trim() + \" {\\n\";\r\n                    str += strNode(\"\",values,depth+1);\r\n                    str += css.SPACE.repeat(depth) + \" }\\n\";\r\n                }\r\n            } else {\r\n                // a selector or a property\r\n                if (langx.isString(values)) {\r\n                    // a css property \r\n                    // ex : (1) font-color : red;\r\n                    str = css.SPACE.repeat(depth) + name.trim() ;\r\n                    if (atFlg) {\r\n                        str = str +  \" \\\"\" + values.trim() + \" \\\";\\n\";\r\n                    } else {\r\n                        str = str + ': ' + values.trim() + \";\\n\";\r\n                    }\r\n\r\n                } else {\r\n                    // a selector rule \r\n                    // ex : (1) .class1 : {\r\n                    //            font-color : red;\r\n                    //          }\r\n                    if (langx.isArray(values)) {\r\n                        // array for ordering\r\n                        for (var n =0; n<values.length; n ++) {\r\n                           str +=  strNode(name,values[n],depth);\r\n                        }\r\n                    } else {\r\n                        // plain object\r\n\r\n                        if (name) {\r\n                            str += css.SPACE.repeat(depth) + name.trim() + \" {\\n\";\r\n\r\n                            for (var n in values) {\r\n                                var value =values[n];\r\n                                if (langx.isString(value)) {\r\n                                    // css property\r\n                                    str += strNode(n,value,depth+1)\r\n                                }\r\n                            }\r\n\r\n                            str += css.SPACE.repeat(depth) + \"}\\n\";\r\n                        }\r\n\r\n                        for (var n in values) {\r\n                            var value =values[n];\r\n                            if (!langx.isString(value)) {\r\n                                var adjusted = adjust(name,n,depth);\r\n                                str +=  strNode(adjusted.name,value,adjusted.depth);\r\n                            } \r\n                        }\r\n\r\n                    }\r\n                }\r\n            }   \r\n\r\n            return str;\r\n        };\r\n\r\n\r\n        return strNode(\"\",json,0);\r\n    }\r\n \r\n\r\n    function css() {\r\n        return css;\r\n    }\r\n\r\n    langx.mixin(css, {\r\n        SPACE : \"\\t\",\r\n\r\n        addRules : addRules,\r\n\r\n        addSheetRules : addSheetRules,\r\n\r\n        createStyleSheet: createStyleSheet,\r\n\r\n        deleteSheetRule : deleteSheetRule,\r\n\r\n        deleteRule : deleteRule,\r\n\r\n        insertRule : insertRule,\r\n\r\n        insertSheetRule : insertSheetRule,\r\n\r\n        removeStyleSheet : removeStyleSheet,\r\n\r\n        toString : toString\r\n    });\r\n\r\n    return skylark.css = css;\r\n});\r\n\ndefine('skylark-utils-css/css',[\r\n    \"skylark-utils/skylark\",\r\n    \"skylark-utils/css\"\r\n], function(skylark, css) {\r\n\t\r\n\treturn css;\r\n});\n/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */\r\n/*\r\n\r\n  The MIT License (MIT)\r\n\r\n  Copyright (c) 2007-2013 Einar Lielmanis and contributors.\r\n\r\n  Permission is hereby granted, free of charge, to any person\r\n  obtaining a copy of this software and associated documentation files\r\n  (the \"Software\"), to deal in the Software without restriction,\r\n  including without limitation the rights to use, copy, modify, merge,\r\n  publish, distribute, sublicense, and/or sell copies of the Software,\r\n  and to permit persons to whom the Software is furnished to do so,\r\n  subject to the following conditions:\r\n\r\n  The above copyright notice and this permission notice shall be\r\n  included in all copies or substantial portions of the Software.\r\n\r\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\r\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\r\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n  SOFTWARE.\r\n\r\n\r\n CSS Beautifier\r\n---------------\r\n\r\n    Written by Harutyun Amirjanyan, (amirjanyan@gmail.com)\r\n\r\n    Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>\r\n        http://jsbeautifier.org/\r\n\r\n    Usage:\r\n        css_beautify(source_text);\r\n        css_beautify(source_text, options);\r\n\r\n    The options are (default in brackets):\r\n        indent_size (4)                    indentation size,\r\n        indent_char (space)                character to indent with,\r\n        selector_separator_newline (true) - separate selectors with newline or\r\n                                            not (e.g. \"a,\\nbr\" or \"a, br\")\r\n        end_with_newline (false)          - end with a newline\r\n\r\n    e.g\r\n\r\n    css_beautify(css_source_text, {\r\n      'indent_size': 1,\r\n      'indent_char': '\\t',\r\n      'selector_separator': ' ',\r\n      'end_with_newline': false,\r\n    });\r\n*/\r\n\r\n// http://www.w3.org/TR/CSS21/syndata.html#tokenization\r\n// http://www.w3.org/TR/css3-syntax/\r\n\r\ndefine('skylark-utils-css/primitives/beautify-css',[],function() {\r\n    function css_beautify(source_text, options) {\r\n        options = options || {};\r\n        var indentSize = options.indent_size || 4;\r\n        var indentCharacter = options.indent_char || ' ';\r\n        var selectorSeparatorNewline = (options.selector_separator_newline === undefined) ? true : options.selector_separator_newline;\r\n        var end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;\r\n\r\n        // compatibility\r\n        if (typeof indentSize === \"string\") {\r\n            indentSize = parseInt(indentSize, 10);\r\n        }\r\n\r\n\r\n        // tokenizer\r\n        var whiteRe = /^\\s+$/;\r\n        var wordRe = /[\\w$\\-_]/;\r\n\r\n        var pos = -1,\r\n            ch;\r\n\r\n        function next() {\r\n            ch = source_text.charAt(++pos);\r\n            return ch || '';\r\n        }\r\n\r\n        function peek(skipWhitespace) {\r\n            var prev_pos = pos;\r\n            if (skipWhitespace) {\r\n                eatWhitespace();\r\n            }\r\n            result = source_text.charAt(pos + 1) || '';\r\n            pos = prev_pos - 1;\r\n            next();\r\n            return result;\r\n        }\r\n\r\n        function eatString(endChars) {\r\n            var start = pos;\r\n            while (next()) {\r\n                if (ch === \"\\\\\") {\r\n                    next();\r\n                } else if (endChars.indexOf(ch) !== -1) {\r\n                    break;\r\n                } else if (ch === \"\\n\") {\r\n                    break;\r\n                }\r\n            }\r\n            return source_text.substring(start, pos + 1);\r\n        }\r\n\r\n        function peekString(endChar) {\r\n            var prev_pos = pos;\r\n            var str = eatString(endChar);\r\n            pos = prev_pos - 1;\r\n            next();\r\n            return str;\r\n        }\r\n\r\n        function eatWhitespace() {\r\n            var result = '';\r\n            while (whiteRe.test(peek())) {\r\n                next()\r\n                result += ch;\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function skipWhitespace() {\r\n            var result = '';\r\n            if (ch && whiteRe.test(ch)) {\r\n                result = ch;\r\n            }\r\n            while (whiteRe.test(next())) {\r\n                result += ch\r\n            }\r\n            return result;\r\n        }\r\n\r\n        function eatComment(singleLine) {\r\n            var start = pos;\r\n            var singleLine = peek() === \"/\";\r\n            next();\r\n            while (next()) {\r\n                if (!singleLine && ch === \"*\" && peek() === \"/\") {\r\n                    next();\r\n                    break;\r\n                } else if (singleLine && ch === \"\\n\") {\r\n                    return source_text.substring(start, pos);\r\n                }\r\n            }\r\n\r\n            return source_text.substring(start, pos) + ch;\r\n        }\r\n\r\n\r\n        function lookBack(str) {\r\n            return source_text.substring(pos - str.length, pos).toLowerCase() ===\r\n                str;\r\n        }\r\n\r\n        // Nested pseudo-class if we are insideRule\r\n        // and the next special character found opens\r\n        // a new block\r\n        function foundNestedPseudoClass() {\r\n            for (var i = pos + 1; i < source_text.length; i++){\r\n                var ch = source_text.charAt(i);\r\n                if (ch === \"{\"){\r\n                    return true;\r\n                } else if (ch === \";\" || ch === \"}\" || ch === \")\") {\r\n                    return false;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n\r\n        // printer\r\n        var basebaseIndentString = source_text.match(/^[\\t ]*/)[0];\r\n        var singleIndent = new Array(indentSize + 1).join(indentCharacter);\r\n        var indentLevel = 0;\r\n        var nestedLevel = 0;\r\n\r\n        function indent() {\r\n            indentLevel++;\r\n            basebaseIndentString += singleIndent;\r\n        }\r\n\r\n        function outdent() {\r\n            indentLevel--;\r\n            basebaseIndentString = basebaseIndentString.slice(0, -indentSize);\r\n        }\r\n\r\n        var print = {};\r\n        print[\"{\"] = function(ch) {\r\n            print.singleSpace();\r\n            output.push(ch);\r\n            print.newLine();\r\n        };\r\n        print[\"}\"] = function(ch) {\r\n            print.newLine();\r\n            output.push(ch);\r\n            print.newLine();\r\n        };\r\n\r\n        print._lastCharWhitespace = function() {\r\n            return whiteRe.test(output[output.length - 1]);\r\n        };\r\n\r\n        print.newLine = function(keepWhitespace) {\r\n            if (!keepWhitespace) {\r\n                print.trim();\r\n            }\r\n\r\n            if (output.length) {\r\n                output.push('\\n');\r\n            }\r\n            if (basebaseIndentString) {\r\n                output.push(basebaseIndentString);\r\n            }\r\n        };\r\n        print.singleSpace = function() {\r\n            if (output.length && !print._lastCharWhitespace()) {\r\n                output.push(' ');\r\n            }\r\n        };\r\n\r\n        print.trim = function() {\r\n            while (print._lastCharWhitespace()) {\r\n                output.pop();\r\n            }\r\n        };\r\n\r\n\r\n        var output = [];\r\n        if (basebaseIndentString) {\r\n            output.push(basebaseIndentString);\r\n        }\r\n        /*_____________________--------------------_____________________*/\r\n\r\n        var insideRule = false;\r\n        var enteringConditionalGroup = false;\r\n        var top_ch = '';\r\n        var last_top_ch = '';\r\n\r\n        while (true) {\r\n            var whitespace = skipWhitespace();\r\n            var isAfterSpace = whitespace !== '';\r\n            var isAfterNewline = whitespace.indexOf('\\n') !== -1;\r\n            var last_top_ch = top_ch;\r\n            var top_ch = ch;\r\n\r\n            if (!ch) {\r\n                break;\r\n            } else if (ch === '/' && peek() === '*') { /* css comment */\r\n                var header = lookBack(\"\");\r\n                print.newLine();\r\n                output.push(eatComment());\r\n                print.newLine();\r\n                if (header) {\r\n                    print.newLine(true);\r\n                }\r\n            } else if (ch === '/' && peek() === '/') { // single line comment\r\n                if (!isAfterNewline && last_top_ch !== '{') {\r\n                    print.trim();\r\n                }\r\n                print.singleSpace();\r\n                output.push(eatComment());\r\n                print.newLine();\r\n            } else if (ch === '@') {\r\n                // pass along the space we found as a separate item\r\n                if (isAfterSpace) {\r\n                    print.singleSpace();\r\n                }\r\n                output.push(ch);\r\n\r\n                // strip trailing space, if present, for hash property checks\r\n                var variableOrRule = peekString(\": ,;{}()[]/='\\\"\").replace(/\\s$/, '');\r\n\r\n                // might be a nesting at-rule\r\n                if (variableOrRule in css_beautify.NESTED_AT_RULE) {\r\n                    nestedLevel += 1;\r\n                    if (variableOrRule in css_beautify.CONDITIONAL_GROUP_RULE) {\r\n                        enteringConditionalGroup = true;\r\n                    }\r\n                } else if (': '.indexOf(variableOrRule[variableOrRule.length -1]) >= 0) {\r\n                    //we have a variable, add it and insert one space before continuing\r\n                    next();\r\n                    variableOrRule = eatString(\": \").replace(/\\s$/, '');\r\n                    output.push(variableOrRule);\r\n                    print.singleSpace();\r\n                }\r\n            } else if (ch === '{') {\r\n                if (peek(true) === '}') {\r\n                    eatWhitespace();\r\n                    next();\r\n                    print.singleSpace();\r\n                    output.push(\"{}\");\r\n                } else {\r\n                    indent();\r\n                    print[\"{\"](ch);\r\n                    // when entering conditional groups, only rulesets are allowed\r\n                    if (enteringConditionalGroup) {\r\n                        enteringConditionalGroup = false;\r\n                        insideRule = (indentLevel > nestedLevel);\r\n                    } else {\r\n                        // otherwise, declarations are also allowed\r\n                        insideRule = (indentLevel >= nestedLevel);\r\n                    }\r\n                }\r\n            } else if (ch === '}') {\r\n                outdent();\r\n                print[\"}\"](ch);\r\n                insideRule = false;\r\n                if (nestedLevel) {\r\n                    nestedLevel--;\r\n                }\r\n            } else if (ch === \":\") {\r\n                eatWhitespace();\r\n                if ((insideRule || enteringConditionalGroup) &&\r\n                        !(lookBack(\"&\") || foundNestedPseudoClass())) {\r\n                    // 'property: value' delimiter\r\n                    // which could be in a conditional group query\r\n                    output.push(':');\r\n                    print.singleSpace();\r\n                } else {\r\n                    // sass/less parent reference don't use a space\r\n                    // sass nested pseudo-class don't use a space\r\n                    if (peek() === \":\") {\r\n                        // pseudo-element\r\n                        next();\r\n                        output.push(\"::\");\r\n                    } else {\r\n                        // pseudo-class\r\n                        output.push(':');\r\n                    }\r\n                }\r\n            } else if (ch === '\"' || ch === '\\'') {\r\n                if (isAfterSpace) {\r\n                    print.singleSpace();\r\n                }\r\n                output.push(eatString(ch));\r\n            } else if (ch === ';') {\r\n                output.push(ch);\r\n                print.newLine();\r\n            } else if (ch === '(') { // may be a url\r\n                if (lookBack(\"url\")) {\r\n                    output.push(ch);\r\n                    eatWhitespace();\r\n                    if (next()) {\r\n                        if (ch !== ')' && ch !== '\"' && ch !== '\\'') {\r\n                            output.push(eatString(')'));\r\n                        } else {\r\n                            pos--;\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (isAfterSpace) {\r\n                        print.singleSpace();\r\n                    }\r\n                    output.push(ch);\r\n                    eatWhitespace();\r\n                }\r\n            } else if (ch === ')') {\r\n                output.push(ch);\r\n            } else if (ch === ',') {\r\n                output.push(ch);\r\n                eatWhitespace();\r\n                if (!insideRule && selectorSeparatorNewline) {\r\n                    print.newLine();\r\n                } else {\r\n                    print.singleSpace();\r\n                }\r\n            } else if (ch === ']') {\r\n                output.push(ch);\r\n            } else if (ch === '[') {\r\n                if (isAfterSpace) {\r\n                    print.singleSpace();\r\n                }\r\n                output.push(ch);\r\n            } else if (ch === '=') { // no whitespace before or after\r\n                eatWhitespace();\r\n                output.push(ch);\r\n            } else {\r\n                if (isAfterSpace) {\r\n                    print.singleSpace();\r\n                }\r\n\r\n                output.push(ch);\r\n            }\r\n        }\r\n\r\n\r\n        var sweetCode = output.join('').replace(/[\\r\\n\\t ]+$/, '');\r\n\r\n        // establish end_with_newline\r\n        if (end_with_newline) {\r\n            sweetCode += \"\\n\";\r\n        }\r\n\r\n        return sweetCode;\r\n    }\r\n\r\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule\r\n    css_beautify.NESTED_AT_RULE = {\r\n        \"@page\": true,\r\n        \"@font-face\": true,\r\n        \"@keyframes\": true,\r\n        // also in CONDITIONAL_GROUP_RULE below\r\n        \"@media\": true,\r\n        \"@supports\": true,\r\n        \"@document\": true\r\n    };\r\n    css_beautify.CONDITIONAL_GROUP_RULE = {\r\n        \"@media\": true,\r\n        \"@supports\": true,\r\n        \"@document\": true\r\n    };\r\n\r\n    return {\r\n        css_beautify: css_beautify\r\n    };\r\n});\r\n\ndefine('skylark-utils-css/beautify',[\r\n    \"./css\",\r\n    \"./primitives/beautify-css\"\r\n], function(css, beautifyCss) {\r\n\r\n\treturn css.beautify = beautifyCss.css_beautify;\r\n});\ndefine('skylark-utils/finder',[\r\n    \"./skylark\",\r\n    \"./langx\",\r\n    \"./browser\",\r\n    \"./noder\"\r\n], function(skylark, langx, browser, noder, velm) {\r\n    var local = {},\r\n        filter = Array.prototype.filter,\r\n        slice = Array.prototype.slice,\r\n        nativeMatchesSelector = browser.matchesSelector;\r\n\r\n    /*\r\n    ---\r\n    name: Slick.Parser\r\n    description: Standalone CSS3 Selector parser\r\n    provides: Slick.Parser\r\n    ...\r\n    */\r\n    ;\r\n    (function() {\r\n\r\n        var parsed,\r\n            separatorIndex,\r\n            combinatorIndex,\r\n            reversed,\r\n            cache = {},\r\n            reverseCache = {},\r\n            reUnescape = /\\\\/g;\r\n\r\n        var parse = function(expression, isReversed) {\r\n            if (expression == null) return null;\r\n            if (expression.Slick === true) return expression;\r\n            expression = ('' + expression).replace(/^\\s+|\\s+$/g, '');\r\n            reversed = !!isReversed;\r\n            var currentCache = (reversed) ? reverseCache : cache;\r\n            if (currentCache[expression]) return currentCache[expression];\r\n            parsed = {\r\n                Slick: true,\r\n                expressions: [],\r\n                raw: expression,\r\n                reverse: function() {\r\n                    return parse(this.raw, true);\r\n                }\r\n            };\r\n            separatorIndex = -1;\r\n            while (expression != (expression = expression.replace(regexp, parser)));\r\n            parsed.length = parsed.expressions.length;\r\n            return currentCache[parsed.raw] = (reversed) ? reverse(parsed) : parsed;\r\n        };\r\n\r\n        var reverseCombinator = function(combinator) {\r\n            if (combinator === '!') return ' ';\r\n            else if (combinator === ' ') return '!';\r\n            else if ((/^!/).test(combinator)) return combinator.replace(/^!/, '');\r\n            else return '!' + combinator;\r\n        };\r\n\r\n        var reverse = function(expression) {\r\n            var expressions = expression.expressions;\r\n            for (var i = 0; i < expressions.length; i++) {\r\n                var exp = expressions[i];\r\n                var last = {\r\n                    parts: [],\r\n                    tag: '*',\r\n                    combinator: reverseCombinator(exp[0].combinator)\r\n                };\r\n\r\n                for (var j = 0; j < exp.length; j++) {\r\n                    var cexp = exp[j];\r\n                    if (!cexp.reverseCombinator) cexp.reverseCombinator = ' ';\r\n                    cexp.combinator = cexp.reverseCombinator;\r\n                    delete cexp.reverseCombinator;\r\n                }\r\n\r\n                exp.reverse().push(last);\r\n            }\r\n            return expression;\r\n        };\r\n\r\n        var escapeRegExp = (function() {\r\n            // Credit: XRegExp 0.6.1 (c) 2007-2008 Steven Levithan <http://stevenlevithan.com/regex/xregexp/> MIT License\r\n            var from = /(?=[\\-\\[\\]{}()*+?.\\\\\\^$|,#\\s])/g,\r\n                to = '\\\\';\r\n            return function(string) {\r\n                return string.replace(from, to)\r\n            }\r\n        }())\r\n\r\n        var regexp = new RegExp(\r\n            \"^(?:\\\\s*(,)\\\\s*|\\\\s*(<combinator>+)\\\\s*|(\\\\s+)|(<unicode>+|\\\\*)|\\\\#(<unicode>+)|\\\\.(<unicode>+)|\\\\[\\\\s*(<unicode1>+)(?:\\\\s*([*^$!~|]?=)(?:\\\\s*(?:([\\\"']?)(.*?)\\\\9)))?\\\\s*\\\\](?!\\\\])|(:+)(<unicode>+)(?:\\\\((?:(?:([\\\"'])([^\\\\13]*)\\\\13)|((?:\\\\([^)]+\\\\)|[^()]*)+))\\\\))?)\"\r\n            .replace(/<combinator>/, '[' + escapeRegExp(\">+~`!@$%^&={}\\\\;</\") + ']')\r\n            .replace(/<unicode>/g, '(?:[\\\\w\\\\u00a1-\\\\uFFFF-]|\\\\\\\\[^\\\\s0-9a-f])')\r\n            .replace(/<unicode1>/g, '(?:[:\\\\w\\\\u00a1-\\\\uFFFF-]|\\\\\\\\[^\\\\s0-9a-f])')\r\n        );\r\n\r\n        function parser(\r\n            rawMatch,\r\n\r\n            separator,\r\n            combinator,\r\n            combinatorChildren,\r\n\r\n            tagName,\r\n            id,\r\n            className,\r\n\r\n            attributeKey,\r\n            attributeOperator,\r\n            attributeQuote,\r\n            attributeValue,\r\n\r\n            pseudoMarker,\r\n            pseudoClass,\r\n            pseudoQuote,\r\n            pseudoClassQuotedValue,\r\n            pseudoClassValue\r\n        ) {\r\n            if (separator || separatorIndex === -1) {\r\n                parsed.expressions[++separatorIndex] = [];\r\n                combinatorIndex = -1;\r\n                if (separator) return '';\r\n            }\r\n\r\n            if (combinator || combinatorChildren || combinatorIndex === -1) {\r\n                combinator = combinator || ' ';\r\n                var currentSeparator = parsed.expressions[separatorIndex];\r\n                if (reversed && currentSeparator[combinatorIndex])\r\n                    currentSeparator[combinatorIndex].reverseCombinator = reverseCombinator(combinator);\r\n                currentSeparator[++combinatorIndex] = {\r\n                    combinator: combinator,\r\n                    tag: '*'\r\n                };\r\n            }\r\n\r\n            var currentParsed = parsed.expressions[separatorIndex][combinatorIndex];\r\n\r\n            if (tagName) {\r\n                currentParsed.tag = tagName.replace(reUnescape, '');\r\n\r\n            } else if (id) {\r\n                currentParsed.id = id.replace(reUnescape, '');\r\n\r\n            } else if (className) {\r\n                className = className.replace(reUnescape, '');\r\n\r\n                if (!currentParsed.classList) currentParsed.classList = [];\r\n                if (!currentParsed.classes) currentParsed.classes = [];\r\n                currentParsed.classList.push(className);\r\n                currentParsed.classes.push({\r\n                    value: className,\r\n                    regexp: new RegExp('(^|\\\\s)' + escapeRegExp(className) + '(\\\\s|$)')\r\n                });\r\n\r\n            } else if (pseudoClass) {\r\n                pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue;\r\n                pseudoClassValue = pseudoClassValue ? pseudoClassValue.replace(reUnescape, '') : null;\r\n\r\n                if (!currentParsed.pseudos) currentParsed.pseudos = [];\r\n                currentParsed.pseudos.push({\r\n                    key: pseudoClass.replace(reUnescape, ''),\r\n                    value: pseudoClassValue,\r\n                    type: pseudoMarker.length == 1 ? 'class' : 'element'\r\n                });\r\n\r\n            } else if (attributeKey) {\r\n                attributeKey = attributeKey.replace(reUnescape, '');\r\n                attributeValue = (attributeValue || '').replace(reUnescape, '');\r\n\r\n                var test, regexp;\r\n\r\n                switch (attributeOperator) {\r\n                    case '^=':\r\n                        regexp = new RegExp('^' + escapeRegExp(attributeValue));\r\n                        break;\r\n                    case '$=':\r\n                        regexp = new RegExp(escapeRegExp(attributeValue) + '$');\r\n                        break;\r\n                    case '~=':\r\n                        regexp = new RegExp('(^|\\\\s)' + escapeRegExp(attributeValue) + '(\\\\s|$)');\r\n                        break;\r\n                    case '|=':\r\n                        regexp = new RegExp('^' + escapeRegExp(attributeValue) + '(-|$)');\r\n                        break;\r\n                    case '=':\r\n                        test = function(value) {\r\n                            return attributeValue == value;\r\n                        };\r\n                        break;\r\n                    case '*=':\r\n                        test = function(value) {\r\n                            return value && value.indexOf(attributeValue) > -1;\r\n                        };\r\n                        break;\r\n                    case '!=':\r\n                        test = function(value) {\r\n                            return attributeValue != value;\r\n                        };\r\n                        break;\r\n                    default:\r\n                        test = function(value) {\r\n                            return !!value;\r\n                        };\r\n                }\r\n\r\n                if (attributeValue == '' && (/^[*$^]=$/).test(attributeOperator)) test = function() {\r\n                    return false;\r\n                };\r\n\r\n                if (!test) test = function(value) {\r\n                    return value && regexp.test(value);\r\n                };\r\n\r\n                if (!currentParsed.attributes) currentParsed.attributes = [];\r\n                currentParsed.attributes.push({\r\n                    key: attributeKey,\r\n                    operator: attributeOperator,\r\n                    value: attributeValue,\r\n                    test: test\r\n                });\r\n\r\n            }\r\n\r\n            return '';\r\n        };\r\n\r\n        // Slick NS\r\n\r\n        var Slick = (this.Slick || {});\r\n\r\n        Slick.parse = function(expression) {\r\n            return parse(expression);\r\n        };\r\n\r\n        Slick.escapeRegExp = escapeRegExp;\r\n\r\n        if (!this.Slick) this.Slick = Slick;\r\n\r\n    }).apply(local);\r\n\r\n\r\n    var simpleClassSelectorRE = /^\\.([\\w-]*)$/,\r\n        simpleIdSelectorRE = /^#([\\w-]*)$/,\r\n        rinputs = /^(?:input|select|textarea|button)$/i,\r\n        rheader = /^h\\d$/i,\r\n        slice = Array.prototype.slice;\r\n\r\n\r\n    local.parseSelector = local.Slick.parse;\r\n\r\n\r\n    var pseudos = local.pseudos = {\r\n        // custom pseudos\r\n        \"button\": function( elem ) {\r\n            var name = elem.nodeName.toLowerCase();\r\n            return name === \"input\" && elem.type === \"button\" || name === \"button\";\r\n        },\r\n\r\n        'checked': function(elm) {\r\n            return !!elm.checked;\r\n        },\r\n\r\n        'contains': function(elm, idx, nodes, text) {\r\n            if ($(this).text().indexOf(text) > -1) return this\r\n        },\r\n\r\n        'disabled': function(elm) {\r\n            return !!elm.disabled;\r\n        },\r\n\r\n        'enabled': function(elm) {\r\n            return !elm.disabled;\r\n        },\r\n\r\n        'eq': function(elm, idx, nodes, value) {\r\n            return (idx == value);\r\n        },\r\n\r\n        'even' : function(elm, idx, nodes, value) {\r\n            return (idx % 2) === 0;\r\n        },\r\n\r\n        'focus': function(elm) {\r\n            return document.activeElement === elm && (elm.href || elm.type || elm.tabindex);\r\n        },\r\n\r\n        'first': function(elm, idx) {\r\n            return (idx === 0);\r\n        },\r\n\r\n        'gt': function(elm, idx, nodes, value) {\r\n            return (idx > value);\r\n        },\r\n\r\n        'has': function(elm, idx, nodes, sel) {\r\n            return find(elm, sel);\r\n        },\r\n\r\n        // Element/input types\r\n        \"header\": function( elem ) {\r\n            return rheader.test( elem.nodeName );\r\n        },\r\n\r\n        'hidden': function(elm) {\r\n            return !local.pseudos[\"visible\"](elm);\r\n        },\r\n\r\n        \"input\": function( elem ) {\r\n            return rinputs.test( elem.nodeName );\r\n        },\r\n\r\n        'last': function(elm, idx, nodes) {\r\n            return (idx === nodes.length - 1);\r\n        },\r\n\r\n        'lt': function(elm, idx, nodes, value) {\r\n            return (idx < value);\r\n        },\r\n\r\n        'not': function(elm, idx, nodes, sel) {\r\n            return !matches(elm, sel);\r\n        },\r\n\r\n        'odd' : function(elm, idx, nodes, value) {\r\n            return (idx % 2) === 1;\r\n        },\r\n\r\n        'parent': function(elm) {\r\n            return !!elm.parentNode;\r\n        },\r\n\r\n        'selected': function(elm) {\r\n            return !!elm.selected;\r\n        },\r\n\r\n        'text': function(elm){\r\n            return elm.type === \"text\";\r\n        },\r\n\r\n        'visible': function(elm) {\r\n            return elm.offsetWidth && elm.offsetWidth\r\n        }\r\n    };\r\n\r\n    [\"first\",\"eq\",\"last\"].forEach(function(item){\r\n        pseudos[item].isArrayFilter = true;\r\n    });\r\n\r\n\r\n\r\n    pseudos[\"nth\"] = pseudos[\"eq\"];\r\n\r\n    function createInputPseudo( type ) {\r\n        return function( elem ) {\r\n            var name = elem.nodeName.toLowerCase();\r\n            return name === \"input\" && elem.type === type;\r\n        };\r\n    }\r\n\r\n    function createButtonPseudo( type ) {\r\n        return function( elem ) {\r\n            var name = elem.nodeName.toLowerCase();\r\n            return (name === \"input\" || name === \"button\") && elem.type === type;\r\n        };\r\n    }\r\n\r\n    // Add button/input type pseudos\r\n    for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\r\n        pseudos[ i ] = createInputPseudo( i );\r\n    }\r\n    for ( i in { submit: true, reset: true } ) {\r\n        pseudos[ i ] = createButtonPseudo( i );\r\n    }\r\n\r\n\r\n    local.divide = function(cond) {\r\n        var nativeSelector = \"\",\r\n            customPseudos = [],\r\n            tag,\r\n            id,\r\n            classes,\r\n            attributes,\r\n            pseudos;\r\n\r\n\r\n        if (id = cond.id) {\r\n            nativeSelector += (\"#\" + id);\r\n        }\r\n        if (classes = cond.classes) {\r\n            for (var i = classes.length; i--;) {\r\n                nativeSelector += (\".\" + classes[i].value);\r\n            }\r\n        }\r\n        if (attributes = cond.attributes) {\r\n            for (var i = 0; i < attributes.length; i++) {\r\n                if (attributes[i].operator) {\r\n                    nativeSelector += (\"[\" + attributes[i].key + attributes[i].operator + JSON.stringify(attributes[i].value)  +\"]\");\r\n                } else {\r\n                    nativeSelector += (\"[\" + attributes[i].key + \"]\");\r\n                }\r\n            }\r\n        }\r\n        if (pseudos = cond.pseudos) {\r\n            for (i = pseudos.length; i--;) {\r\n                part = pseudos[i];\r\n                if (this.pseudos[part.key]) {\r\n                    customPseudos.push(part);\r\n                } else {\r\n                    if (part.value !== undefined) {\r\n                        nativeSelector += (\":\" + part.key + \"(\" + JSON.stringify(part))\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (tag = cond.tag) {\r\n            if (tag !== \"*\") {\r\n                nativeSelector = tag.toUpperCase() + nativeSelector;\r\n            }\r\n        }\r\n\r\n        if (!nativeSelector) {\r\n            nativeSelector = \"*\";\r\n        }\r\n\r\n        return {\r\n            nativeSelector: nativeSelector,\r\n            customPseudos: customPseudos\r\n        }\r\n\r\n    };\r\n\r\n    local.check = function(node, cond, idx, nodes,arrayFilte) {\r\n        var tag,\r\n            id,\r\n            classes,\r\n            attributes,\r\n            pseudos,\r\n\r\n            i, part, cls, pseudo;\r\n\r\n        if (!arrayFilte) {\r\n            if (tag = cond.tag) {\r\n                var nodeName = node.nodeName.toUpperCase();\r\n                if (tag == '*') {\r\n                    if (nodeName < '@') return false; // Fix for comment nodes and closed nodes\r\n                } else {\r\n                    if (nodeName != (tag || \"\").toUpperCase()) return false;\r\n                }\r\n            }\r\n\r\n            if (id = cond.id) {\r\n                if (node.getAttribute('id') != id) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n\r\n            if (classes = cond.classes) {\r\n                for (i = classes.length; i--;) {\r\n                    cls = node.getAttribute('class');\r\n                    if (!(cls && classes[i].regexp.test(cls))) return false;\r\n                }\r\n            }\r\n\r\n            if (attributes = cond.attributes) {\r\n                 for (i = attributes.length; i--;) {\r\n                    part = attributes[i];\r\n                    if (part.operator ? !part.test(node.getAttribute(part.key)) : !node.hasAttribute(part.key)) return false;\r\n                }\r\n            }\r\n\r\n        }\r\n        if (pseudos = cond.pseudos) {\r\n            for (i = pseudos.length; i--;) {\r\n                part = pseudos[i];\r\n                if (pseudo = this.pseudos[part.key]) {\r\n                    if ((arrayFilte && pseudo.isArrayFilter) || (!arrayFilte && !pseudo.isArrayFilter)) {\r\n                        if (!pseudo(node, idx, nodes, part.value)) {\r\n                            return false;\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (!arrayFilte && !nativeMatchesSelector.call(node, part.key)) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    local.match = function(node, selector) {\r\n\r\n        var parsed ;\r\n\r\n        if (langx.isString(selector)) {\r\n            parsed = local.Slick.parse(selector);\r\n        } else {\r\n            parsed = selector;            \r\n        }\r\n        \r\n        if (!parsed) {\r\n            return true;\r\n        }\r\n\r\n        // simple (single) selectors\r\n        var expressions = parsed.expressions,\r\n            simpleExpCounter = 0,\r\n            i,\r\n            currentExpression;\r\n        for (i = 0;\r\n            (currentExpression = expressions[i]); i++) {\r\n            if (currentExpression.length == 1) {\r\n                var exp = currentExpression[0];\r\n                if (this.check(node,exp)) {\r\n                    return true;\r\n                }\r\n                simpleExpCounter++;\r\n            }\r\n        }\r\n\r\n        if (simpleExpCounter == parsed.length) {\r\n            return false;\r\n        }\r\n\r\n        var nodes = this.query(document, parsed),\r\n            item;\r\n        for (i = 0; item = nodes[i++];) {\r\n            if (item === node) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n\r\n\r\n    local.filterSingle = function(nodes, exp){\r\n        var matchs = filter.call(nodes, function(node, idx) {\r\n            return local.check(node, exp, idx, nodes,false);\r\n        });    \r\n\r\n        matchs = filter.call(matchs, function(node, idx) {\r\n            return local.check(node, exp, idx, matchs,true);\r\n        }); \r\n        return matchs;\r\n    };\r\n\r\n    local.filter = function(nodes, selector) {\r\n        var parsed;\r\n\r\n        if (langx.isString(selector)) {\r\n            parsed = local.Slick.parse(selector);\r\n        } else {\r\n            return local.filterSingle(nodes,selector);           \r\n        }\r\n\r\n        // simple (single) selectors\r\n        var expressions = parsed.expressions,\r\n            i,\r\n            currentExpression,\r\n            ret = [];\r\n        for (i = 0;\r\n            (currentExpression = expressions[i]); i++) {\r\n            if (currentExpression.length == 1) {\r\n                var exp = currentExpression[0];\r\n\r\n                var matchs = local.filterSingle(nodes,exp);  \r\n\r\n                ret = langx.uniq(ret.concat(matchs));\r\n            } else {\r\n                throw new Error(\"not supported selector:\" + selector);\r\n            }\r\n        }\r\n\r\n        return ret;\r\n \r\n    };    \r\n\r\n    local.combine = function(elm, bit) {\r\n        var op = bit.combinator,\r\n            cond = bit,\r\n            node1,\r\n            nodes = [];\r\n\r\n        switch (op) {\r\n            case '>': // direct children\r\n                nodes = children(elm, cond);\r\n                break;\r\n            case '+': // next sibling\r\n                node1 = nextSibling(elm, cond, true);\r\n                if (node1) {\r\n                    nodes.push(node1);\r\n                }\r\n                break;\r\n            case '^': // first child\r\n                node1 = firstChild(elm, cond, true);\r\n                if (node1) {\r\n                    nodes.push(node1);\r\n                }\r\n                break;\r\n            case '~': // next siblings\r\n                nodes = nextSiblings(elm, cond);\r\n                break;\r\n            case '++': // next sibling and previous sibling\r\n                var prev = previousSibling(elm, cond, true),\r\n                    next = nextSibling(elm, cond, true);\r\n                if (prev) {\r\n                    nodes.push(prev);\r\n                }\r\n                if (next) {\r\n                    nodes.push(next);\r\n                }\r\n                break;\r\n            case '~~': // next siblings and previous siblings\r\n                nodes = siblings(elm, cond);\r\n                break;\r\n            case '!': // all parent nodes up to document\r\n                nodes = ancestors(elm, cond);\r\n                break;\r\n            case '!>': // direct parent (one level)\r\n                node1 = parent(elm, cond);\r\n                if (node1) {\r\n                    nodes.push(node1);\r\n                }\r\n                break;\r\n            case '!+': // previous sibling\r\n                nodes = previousSibling(elm, cond, true);\r\n                break;\r\n            case '!^': // last child\r\n                node1 = lastChild(elm, cond, true);\r\n                if (node1) {\r\n                    nodes.push(node1);\r\n                }\r\n                break;\r\n            case '!~': // previous siblings\r\n                nodes = previousSiblings(elm, cond);\r\n                break;\r\n            default:\r\n                var divided = this.divide(bit);\r\n                nodes = slice.call(elm.querySelectorAll(divided.nativeSelector));\r\n                if (divided.customPseudos) {\r\n                    for (var i = divided.customPseudos.length - 1; i >= 0; i--) {\r\n                        nodes = filter.call(nodes, function(item, idx) {\r\n                            return local.check(item, {\r\n                                pseudos: [divided.customPseudos[i]]\r\n                            }, idx, nodes,false)\r\n                        });\r\n\r\n                        nodes = filter.call(nodes, function(item, idx) {\r\n                            return local.check(item, {\r\n                                pseudos: [divided.customPseudos[i]]\r\n                            }, idx, nodes,true)\r\n                        });                        \r\n                    }\r\n                }\r\n                break;\r\n\r\n        }\r\n        return nodes;\r\n    }\r\n\r\n    local.query = function(node, selector, single) {\r\n\r\n\r\n        var parsed = this.Slick.parse(selector);\r\n\r\n        var\r\n            founds = [],\r\n            currentExpression, currentBit,\r\n            expressions = parsed.expressions;\r\n\r\n        for (var i = 0;\r\n            (currentExpression = expressions[i]); i++) {\r\n            var currentItems = [node],\r\n                found;\r\n            for (var j = 0;\r\n                (currentBit = currentExpression[j]); j++) {\r\n                found = langx.map(currentItems, function(item, i) {\r\n                    return local.combine(item, currentBit)\r\n                });\r\n                if (found) {\r\n                    currentItems = found;\r\n                }\r\n            }\r\n            if (found) {\r\n                founds = founds.concat(found);\r\n            }\r\n        }\r\n\r\n        return founds;\r\n    }\r\n\r\n\r\n    function ancestor(node, selector, root) {\r\n        var rootIsSelector = root && langx.isString(root);\r\n        while (node = node.parentNode) {\r\n            if (matches(node, selector)) {\r\n                return node;\r\n            }\r\n            if (root) {\r\n                if (rootIsSelector) {\r\n                    if (matches(node,root)) {\r\n                        break;\r\n                    }\r\n                } else if (node == root) {\r\n                    break;\r\n                }\r\n            } \r\n        }\r\n        return null;\r\n    }\r\n\r\n    function ancestors(node, selector,root) {\r\n        var ret = [],\r\n            rootIsSelector = root && langx.isString(root);\r\n        while ((node = node.parentNode) && (node.nodeType !== 9)) {\r\n            ret.push(node);\r\n            if (root) {\r\n                if (rootIsSelector) {\r\n                    if (matches(node,root)) {\r\n                        break;\r\n                    }\r\n                } else if (node == root) {\r\n                    break;\r\n                }\r\n            } \r\n\r\n        }\r\n\r\n        if (selector) {\r\n            ret = local.filter(ret,selector);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    function byId(id, doc) {\r\n        doc = doc || noder.doc();\r\n        return doc.getElementById(id);\r\n    }\r\n\r\n    function children(node, selector) {\r\n        var childNodes = node.childNodes,\r\n            ret = [];\r\n        for (var i = 0; i < childNodes.length; i++) {\r\n            var node = childNodes[i];\r\n            if (node.nodeType == 1) {\r\n                ret.push(node);\r\n            }\r\n        }\r\n        if (selector) {\r\n            ret = local.filter(ret,selector);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    function closest(node, selector) {\r\n        while (node && !(matches(node, selector))) {\r\n            node = node.parentNode;\r\n        }\r\n\r\n        return node;\r\n    }\r\n\r\n    function descendants(elm, selector) {\r\n        // Selector\r\n        try {\r\n            return slice.call(elm.querySelectorAll(selector));\r\n        } catch (matchError) {\r\n            //console.log(matchError);\r\n        }\r\n        return local.query(elm, selector);\r\n    }\r\n\r\n    function descendant(elm, selector) {\r\n        // Selector\r\n        try {\r\n            return elm.querySelector(selector);\r\n        } catch (matchError) {\r\n            //console.log(matchError);\r\n        }\r\n        var nodes = local.query(elm, selector);\r\n        if (nodes.length > 0) {\r\n            return nodes[0];\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    function find(elm,selector) {\r\n        if (!selector) {\r\n            selector = elm;\r\n            elm = document.body;\r\n        }\r\n        if (matches(elm,selector)) {\r\n            return elm;\r\n        } else {\r\n            return descendant(elm, selector);\r\n        }\r\n    }\r\n\r\n    function findAll(elm,selector) {\r\n        if (!selector) {\r\n            selector = elm;\r\n            elm = document.body;\r\n        }\r\n        return descendants(elm, selector);\r\n    }\r\n\r\n    function firstChild(elm, selector, first) {\r\n        var childNodes = elm.childNodes,\r\n            node = childNodes[0];\r\n        while (node) {\r\n            if (node.nodeType == 1) {\r\n                if (!selector || matches(node, selector)) {\r\n                    return node;\r\n                }\r\n                if (first) {\r\n                    break;\r\n                }\r\n            }\r\n            node = node.nextSibling;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    function lastChild(elm, selector, last) {\r\n        var childNodes = elm.childNodes,\r\n            node = childNodes[childNodes.length - 1];\r\n        while (node) {\r\n            if (node.nodeType == 1) {\r\n                if (!selector || matches(node, selector)) {\r\n                    return node;\r\n                }\r\n                if (last) {\r\n                    break;\r\n                }\r\n            }\r\n            node = node.previousSibling;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    function matches(elm, selector) {\r\n        if (!selector || !elm || elm.nodeType !== 1) {\r\n            return false\r\n        }\r\n\r\n        if (langx.isString(selector)) {\r\n            try {\r\n                return nativeMatchesSelector.call(elm, selector.replace(/\\[([^=]+)=\\s*([^'\"\\]]+?)\\s*\\]/g, '[$1=\"$2\"]'));\r\n            } catch (matchError) {\r\n                //console.log(matchError);\r\n            }\r\n            return local.match(elm, selector);\r\n        } else if (langx.isArrayLike(selector)) {\r\n            return langx.inArray(elm,selector) > -1;\r\n        } else if (langx.isPlainObject(selector)){    \r\n            return local.check(elm, selector);\r\n        } else {\r\n            return elm === selector;\r\n        }\r\n\r\n    }\r\n\r\n    function nextSibling(elm, selector, adjacent) {\r\n        var node = elm.nextSibling;\r\n        while (node) {\r\n            if (node.nodeType == 1) {\r\n                if (!selector || matches(node, selector)) {\r\n                    return node;\r\n                }\r\n                if (adjacent) {\r\n                    break;\r\n                }\r\n            }\r\n            node = node.nextSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    function nextSiblings(elm, selector) {\r\n        var node = elm.nextSibling,\r\n            ret = [];\r\n        while (node) {\r\n            if (node.nodeType == 1) {\r\n                if (!selector || matches(node, selector)) {\r\n                    ret.push(node);\r\n                }\r\n            }\r\n            node = node.nextSibling;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n\r\n    function parent(elm, selector) {\r\n        var node = elm.parentNode;\r\n        if (node && (!selector || matches(node, selector))) {\r\n            return node;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    function previousSibling(elm, selector, adjacent) {\r\n        var node = elm.previousSibling;\r\n        while (node) {\r\n            if (node.nodeType == 1) {\r\n                if (!selector || matches(node, selector)) {\r\n                    return node;\r\n                }\r\n                if (adjacent) {\r\n                    break;\r\n                }\r\n            }\r\n            node = node.previousSibling;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    function previousSiblings(elm, selector) {\r\n        var node = elm.previousSibling,\r\n            ret = [];\r\n        while (node) {\r\n            if (node.nodeType == 1) {\r\n                if (!selector || matches(node, selector)) {\r\n                    ret.push(node);\r\n                }\r\n            }\r\n            node = node.previousSibling;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    function siblings(elm, selector) {\r\n        var node = elm.parentNode.firstChild,\r\n            ret = [];\r\n        while (node) {\r\n            if (node.nodeType == 1 && node !== elm) {\r\n                if (!selector || matches(node, selector)) {\r\n                    ret.push(node);\r\n                }\r\n            }\r\n            node = node.nextSibling;\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    var finder = function() {\r\n        return finder;\r\n    };\r\n\r\n    langx.mixin(finder, {\r\n\r\n        ancestor: ancestor,\r\n\r\n        ancestors: ancestors,\r\n\r\n        byId: byId,\r\n\r\n        children: children,\r\n\r\n        closest: closest,\r\n\r\n        descendant: descendant,\r\n\r\n        descendants: descendants,\r\n\r\n        find: find,\r\n\r\n        findAll: findAll,\r\n\r\n        firstChild: firstChild,\r\n\r\n        lastChild: lastChild,\r\n\r\n        matches: matches,\r\n\r\n        nextSibling: nextSibling,\r\n\r\n        nextSiblings: nextSiblings,\r\n\r\n        parent: parent,\r\n\r\n        previousSibling: previousSibling,\r\n\r\n        previousSiblings: previousSiblings,\r\n\r\n        pseudos: local.pseudos,\r\n\r\n        siblings: siblings\r\n    });\r\n\r\n    return skylark.finder = finder;\r\n});\r\n\ndefine('skylark-utils/scripter',[\r\n    \"./skylark\",\r\n    \"./langx\",\r\n    \"./noder\",\r\n    \"./finder\"\r\n], function(skylark, langx, noder, finder) {\r\n\r\n    var head = document.getElementsByTagName('head')[0],\r\n        scriptsByUrl = {},\r\n        scriptElementsById = {},\r\n        count = 0;\r\n\r\n    function scripter() {\r\n        return scripter;\r\n    }\r\n\r\n    langx.mixin(scripter, {\r\n\r\n        loadJavaScript: function(url, loadedCallback, errorCallback) {\r\n            var script = scriptsByUrl[url];\r\n            if (!script) {\r\n                script = scriptsByUrl[url] = {\r\n                    state: 0, //0:unload,1:loaded,-1:loaderror\r\n                    loadedCallbacks: [],\r\n                    errorCallbacks: []\r\n                }\r\n            }\r\n\r\n            script.loadedCallbacks.push(loadedCallback);\r\n            script.errorCallbacks.push(errorCallback);\r\n\r\n            if (script.state === 1) {\r\n                script.node.onload();\r\n            } else if (script.state === -1) {\r\n                script.node.onerror();\r\n            } else {\r\n                var node = script.node = document.createElement(\"script\"),\r\n                    id = script.id = (count++);\r\n\r\n                node.type = \"text/javascript\";\r\n                node.async = false;\r\n                node.defer = false;\r\n                startTime = new Date().getTime();\r\n                head.appendChild(node);\r\n\r\n                node.onload = function() {\r\n                        script.state = 1;\r\n\r\n                        var callbacks = script.loadedCallbacks,\r\n                            i = callbacks.length;\r\n\r\n                        while (i--) {\r\n                            callbacks[i]();\r\n                        }\r\n                        script.loadedCallbacks = [];\r\n                        script.errorCallbacks = [];\r\n                    },\r\n                    node.onerror = function() {\r\n                        script.state = -1;\r\n                        var callbacks = script.errorCallbacks,\r\n                            i = callbacks.length;\r\n\r\n                        while (i--) {\r\n                            callbacks[i]();\r\n                        }\r\n                        script.loadedCallbacks = [];\r\n                        script.errorCallbacks = [];\r\n                    };\r\n                node.src = url;\r\n\r\n                scriptElementsById[id] = node;\r\n            }\r\n            return script.id;\r\n        },\r\n\r\n        deleteJavaScript: function(id) {\r\n            var node = scriptElementsById[id];\r\n            if (node) {\r\n                var url = node.src;\r\n                noder.remove(node);\r\n                delete scriptElementsById[id];\r\n                delete scriptsByUrl[url];\r\n            }\r\n        }\r\n    });\r\n\r\n    return skylark.scripter = scripter;\r\n});\r\n\ndefine('skylark-utils-js/js',[\r\n    \"skylark-utils/skylark\",\r\n    \"skylark-utils/scripter\"\r\n], function(skylark, scripter) {\r\n\t\r\n\treturn scripter;\r\n});\n/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */\r\n/*\r\n\r\n  The MIT License (MIT)\r\n\r\n  Copyright (c) 2007-2013 Einar Lielmanis and contributors.\r\n\r\n  Permission is hereby granted, free of charge, to any person\r\n  obtaining a copy of this software and associated documentation files\r\n  (the \"Software\"), to deal in the Software without restriction,\r\n  including without limitation the rights to use, copy, modify, merge,\r\n  publish, distribute, sublicense, and/or sell copies of the Software,\r\n  and to permit persons to whom the Software is furnished to do so,\r\n  subject to the following conditions:\r\n\r\n  The above copyright notice and this permission notice shall be\r\n  included in all copies or substantial portions of the Software.\r\n\r\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\r\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\r\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\r\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n  SOFTWARE.\r\n\r\n JS Beautifier\r\n---------------\r\n\r\n\r\n  Written by Einar Lielmanis, <einar@jsbeautifier.org>\r\n      http://jsbeautifier.org/\r\n\r\n  Originally converted to javascript by Vital, <vital76@gmail.com>\r\n  \"End braces on own line\" added by Chris J. Shull, <chrisjshull@gmail.com>\r\n  Parsing improvements for brace-less statements by Liam Newman <bitwiseman@gmail.com>\r\n\r\n\r\n  Usage:\r\n    js_beautify(js_source_text);\r\n    js_beautify(js_source_text, options);\r\n\r\n  The options are:\r\n    indent_size (default 4)          - indentation size,\r\n    indent_char (default space)      - character to indent with,\r\n    preserve_newlines (default true) - whether existing line breaks should be preserved,\r\n    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk,\r\n\r\n    jslint_happy (default false) - if true, then jslint-stricter mode is enforced.\r\n\r\n            jslint_happy        !jslint_happy\r\n            ---------------------------------\r\n            function ()         function()\r\n\r\n            switch () {         switch() {\r\n            case 1:               case 1:\r\n              break;                break;\r\n            }                   }\r\n\r\n    space_after_anon_function (default false) - should the space before an anonymous function's parens be added, \"function()\" vs \"function ()\",\r\n          NOTE: This option is overriden by jslint_happy (i.e. if jslint_happy is true, space_after_anon_function is true by design)\r\n\r\n    brace_style (default \"collapse\") - \"collapse\" | \"expand\" | \"end-expand\" | \"none\"\r\n            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.\r\n\r\n    space_before_conditional (default true) - should the space before conditional statement be added, \"if(true)\" vs \"if (true)\",\r\n\r\n    unescape_strings (default false) - should printable characters in strings encoded in \\xNN notation be unescaped, \"example\" vs \"\\x65\\x78\\x61\\x6d\\x70\\x6c\\x65\"\r\n\r\n    wrap_line_length (default unlimited) - lines should wrap at next opportunity after this number of characters.\r\n          NOTE: This is not a hard limit. Lines will continue until a point where a newline would\r\n                be preserved if it were present.\r\n\r\n    end_with_newline (default false)  - end output with a newline\r\n\r\n\r\n    e.g\r\n\r\n    js_beautify(js_source_text, {\r\n      'indent_size': 1,\r\n      'indent_char': '\\t'\r\n    });\r\n\r\n*/\r\n\r\ndefine('skylark-utils-js/primitives/beautify-js',[],function() {\r\n\r\n    var acorn = {};\r\n    (function (exports) {\r\n      // This section of code is taken from acorn.\r\n      //\r\n      // Acorn was written by Marijn Haverbeke and released under an MIT\r\n      // license. The Unicode regexps (for identifiers and whitespace) were\r\n      // taken from [Esprima](http://esprima.org) by Ariya Hidayat.\r\n      //\r\n      // Git repositories for Acorn are available at\r\n      //\r\n      //     http://marijnhaverbeke.nl/git/acorn\r\n      //     https://github.com/marijnh/acorn.git\r\n\r\n      // ## Character categories\r\n\r\n      // Big ugly regular expressions that match characters in the\r\n      // whitespace, identifier, and identifier-start categories. These\r\n      // are only applied when a character is found to actually have a\r\n      // code point above 128.\r\n\r\n      var nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\r\n      var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\r\n      var nonASCIIidentifierChars = \"\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\r\n      var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\r\n      var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\r\n\r\n      // Whether a single character denotes a newline.\r\n\r\n      var newline = exports.newline = /[\\n\\r\\u2028\\u2029]/;\r\n\r\n      // Matches a whole line break (where CRLF is considered a single\r\n      // line break). Used to count lines.\r\n\r\n      var lineBreak = /\\r\\n|[\\n\\r\\u2028\\u2029]/g;\r\n\r\n      // Test whether a given character code starts an identifier.\r\n\r\n      var isIdentifierStart = exports.isIdentifierStart = function(code) {\r\n        if (code < 65) return code === 36;\r\n        if (code < 91) return true;\r\n        if (code < 97) return code === 95;\r\n        if (code < 123)return true;\r\n        return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\r\n      };\r\n\r\n      // Test whether a given character is part of an identifier.\r\n\r\n      var isIdentifierChar = exports.isIdentifierChar = function(code) {\r\n        if (code < 48) return code === 36;\r\n        if (code < 58) return true;\r\n        if (code < 65) return false;\r\n        if (code < 91) return true;\r\n        if (code < 97) return code === 95;\r\n        if (code < 123)return true;\r\n        return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\r\n      };\r\n    })(acorn);\r\n\r\n    function in_array(what, arr) {\r\n        for (var i = 0; i < arr.length; i += 1) {\r\n            if (arr[i] === what) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function trim(s) {\r\n        return s.replace(/^\\s+|\\s+$/g, '');\r\n    }\r\n\r\n    function js_beautify(js_source_text, options) {\r\n        \"use strict\";\r\n        var beautifier = new Beautifier(js_source_text, options);\r\n        return beautifier.beautify();\r\n    }\r\n\r\n    var MODE = {\r\n            BlockStatement: 'BlockStatement', // 'BLOCK'\r\n            Statement: 'Statement', // 'STATEMENT'\r\n            ObjectLiteral: 'ObjectLiteral', // 'OBJECT',\r\n            ArrayLiteral: 'ArrayLiteral', //'[EXPRESSION]',\r\n            ForInitializer: 'ForInitializer', //'(FOR-EXPRESSION)',\r\n            Conditional: 'Conditional', //'(COND-EXPRESSION)',\r\n            Expression: 'Expression' //'(EXPRESSION)'\r\n        };\r\n\r\n    function Beautifier(js_source_text, options) {\r\n        \"use strict\";\r\n        var output\r\n        var tokens = [], token_pos;\r\n        var Tokenizer;\r\n        var current_token;\r\n        var last_type, last_last_text, indent_string;\r\n        var flags, previous_flags, flag_store;\r\n        var prefix;\r\n\r\n        var handlers, opt;\r\n        var baseIndentString = '';\r\n\r\n        handlers = {\r\n            'TK_START_EXPR': handle_start_expr,\r\n            'TK_END_EXPR': handle_end_expr,\r\n            'TK_START_BLOCK': handle_start_block,\r\n            'TK_END_BLOCK': handle_end_block,\r\n            'TK_WORD': handle_word,\r\n            'TK_RESERVED': handle_word,\r\n            'TK_SEMICOLON': handle_semicolon,\r\n            'TK_STRING': handle_string,\r\n            'TK_EQUALS': handle_equals,\r\n            'TK_OPERATOR': handle_operator,\r\n            'TK_COMMA': handle_comma,\r\n            'TK_BLOCK_COMMENT': handle_block_comment,\r\n            'TK_INLINE_COMMENT': handle_inline_comment,\r\n            'TK_COMMENT': handle_comment,\r\n            'TK_DOT': handle_dot,\r\n            'TK_UNKNOWN': handle_unknown,\r\n            'TK_EOF': handle_eof\r\n        };\r\n\r\n        function create_flags(flags_base, mode) {\r\n            var next_indent_level = 0;\r\n            if (flags_base) {\r\n                next_indent_level = flags_base.indentation_level;\r\n                if (!output.just_added_newline() &&\r\n                    flags_base.line_indent_level > next_indent_level) {\r\n                    next_indent_level = flags_base.line_indent_level;\r\n                }\r\n            }\r\n\r\n            var next_flags = {\r\n                mode: mode,\r\n                parent: flags_base,\r\n                last_text: flags_base ? flags_base.last_text : '', // last token text\r\n                last_word: flags_base ? flags_base.last_word : '', // last 'TK_WORD' passed\r\n                declaration_statement: false,\r\n                declaration_assignment: false,\r\n                multiline_frame: false,\r\n                if_block: false,\r\n                else_block: false,\r\n                do_block: false,\r\n                do_while: false,\r\n                in_case_statement: false, // switch(..){ INSIDE HERE }\r\n                in_case: false, // we're on the exact line with \"case 0:\"\r\n                case_body: false, // the indented case-action block\r\n                indentation_level: next_indent_level,\r\n                line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,\r\n                start_line_index: output.get_line_number(),\r\n                ternary_depth: 0\r\n            };\r\n            return next_flags;\r\n        }\r\n\r\n        // Some interpreters have unexpected results with foo = baz || bar;\r\n        options = options ? options : {};\r\n        opt = {};\r\n\r\n        // compatibility\r\n        if (options.braces_on_own_line !== undefined) { //graceful handling of deprecated option\r\n            opt.brace_style = options.braces_on_own_line ? \"expand\" : \"collapse\";\r\n        }\r\n        opt.brace_style = options.brace_style ? options.brace_style : (opt.brace_style ? opt.brace_style : \"collapse\");\r\n\r\n        // graceful handling of deprecated option\r\n        if (opt.brace_style === \"expand-strict\") {\r\n            opt.brace_style = \"expand\";\r\n        }\r\n\r\n\r\n        opt.indent_size = options.indent_size ? parseInt(options.indent_size, 10) : 4;\r\n        opt.indent_char = options.indent_char ? options.indent_char : ' ';\r\n        opt.preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;\r\n        opt.break_chained_methods = (options.break_chained_methods === undefined) ? false : options.break_chained_methods;\r\n        opt.max_preserve_newlines = (options.max_preserve_newlines === undefined) ? 0 : parseInt(options.max_preserve_newlines, 10);\r\n        opt.space_in_paren = (options.space_in_paren === undefined) ? false : options.space_in_paren;\r\n        opt.space_in_empty_paren = (options.space_in_empty_paren === undefined) ? false : options.space_in_empty_paren;\r\n        opt.jslint_happy = (options.jslint_happy === undefined) ? false : options.jslint_happy;\r\n        opt.space_after_anon_function = (options.space_after_anon_function === undefined) ? false : options.space_after_anon_function;\r\n        opt.keep_array_indentation = (options.keep_array_indentation === undefined) ? false : options.keep_array_indentation;\r\n        opt.space_before_conditional = (options.space_before_conditional === undefined) ? true : options.space_before_conditional;\r\n        opt.unescape_strings = (options.unescape_strings === undefined) ? false : options.unescape_strings;\r\n        opt.wrap_line_length = (options.wrap_line_length === undefined) ? 0 : parseInt(options.wrap_line_length, 10);\r\n        opt.e4x = (options.e4x === undefined) ? false : options.e4x;\r\n        opt.end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;\r\n\r\n\r\n        // force opt.space_after_anon_function to true if opt.jslint_happy\r\n        if(opt.jslint_happy) {\r\n            opt.space_after_anon_function = true;\r\n        }\r\n\r\n        if(options.indent_with_tabs){\r\n            opt.indent_char = '\\t';\r\n            opt.indent_size = 1;\r\n        }\r\n\r\n        //----------------------------------\r\n        indent_string = '';\r\n        while (opt.indent_size > 0) {\r\n            indent_string += opt.indent_char;\r\n            opt.indent_size -= 1;\r\n        }\r\n\r\n        var preindent_index = 0;\r\n        if(js_source_text && js_source_text.length) {\r\n            while ( (js_source_text.charAt(preindent_index) === ' ' ||\r\n                    js_source_text.charAt(preindent_index) === '\\t')) {\r\n                baseIndentString += js_source_text.charAt(preindent_index);\r\n                preindent_index += 1;\r\n            }\r\n            js_source_text = js_source_text.substring(preindent_index);\r\n        }\r\n\r\n        last_type = 'TK_START_BLOCK'; // last token type\r\n        last_last_text = ''; // pre-last token text\r\n        output = new Output(indent_string, baseIndentString);\r\n\r\n\r\n        // Stack of parsing/formatting states, including MODE.\r\n        // We tokenize, parse, and output in an almost purely a forward-only stream of token input\r\n        // and formatted output.  This makes the beautifier less accurate than full parsers\r\n        // but also far more tolerant of syntax errors.\r\n        //\r\n        // For example, the default mode is MODE.BlockStatement. If we see a '{' we push a new frame of type\r\n        // MODE.BlockStatement on the the stack, even though it could be object literal.  If we later\r\n        // encounter a \":\", we'll switch to to MODE.ObjectLiteral.  If we then see a \";\",\r\n        // most full parsers would die, but the beautifier gracefully falls back to\r\n        // MODE.BlockStatement and continues on.\r\n        flag_store = [];\r\n        set_mode(MODE.BlockStatement);\r\n\r\n        this.beautify = function() {\r\n\r\n            /*jshint onevar:true */\r\n            var local_token, sweet_code;\r\n            Tokenizer = new tokenizer(js_source_text, opt, indent_string);\r\n            tokens = Tokenizer.tokenize();\r\n            token_pos = 0;\r\n\r\n            while (local_token = get_token()) {\r\n                for(var i = 0; i < local_token.comments_before.length; i++) {\r\n                    // The cleanest handling of inline comments is to treat them as though they aren't there.\r\n                    // Just continue formatting and the behavior should be logical.\r\n                    // Also ignore unknown tokens.  Again, this should result in better behavior.\r\n                    handle_token(local_token.comments_before[i]);\r\n                }\r\n                handle_token(local_token);\r\n\r\n                last_last_text = flags.last_text;\r\n                last_type = local_token.type;\r\n                flags.last_text = local_token.text;\r\n\r\n                token_pos += 1;\r\n            }\r\n\r\n            sweet_code = output.get_code();\r\n            if (opt.end_with_newline) {\r\n                sweet_code += '\\n';\r\n            }\r\n\r\n            return sweet_code;\r\n        };\r\n\r\n        function handle_token(local_token) {\r\n            var newlines = local_token.newlines;\r\n            var keep_whitespace = opt.keep_array_indentation && is_array(flags.mode);\r\n\r\n            if (keep_whitespace) {\r\n                for (i = 0; i < newlines; i += 1) {\r\n                    print_newline(i > 0);\r\n                }\r\n            } else {\r\n                if (opt.max_preserve_newlines && newlines > opt.max_preserve_newlines) {\r\n                    newlines = opt.max_preserve_newlines;\r\n                }\r\n\r\n                if (opt.preserve_newlines) {\r\n                    if (local_token.newlines > 1) {\r\n                        print_newline();\r\n                        for (var i = 1; i < newlines; i += 1) {\r\n                            print_newline(true);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            current_token = local_token;\r\n            handlers[current_token.type]();\r\n        }\r\n\r\n        // we could use just string.split, but\r\n        // IE doesn't like returning empty strings\r\n\r\n        function split_newlines(s) {\r\n            //return s.split(/\\x0d\\x0a|\\x0a/);\r\n\r\n            s = s.replace(/\\x0d/g, '');\r\n            var out = [],\r\n                idx = s.indexOf(\"\\n\");\r\n            while (idx !== -1) {\r\n                out.push(s.substring(0, idx));\r\n                s = s.substring(idx + 1);\r\n                idx = s.indexOf(\"\\n\");\r\n            }\r\n            if (s.length) {\r\n                out.push(s);\r\n            }\r\n            return out;\r\n        }\r\n\r\n        function allow_wrap_or_preserved_newline(force_linewrap) {\r\n            force_linewrap = (force_linewrap === undefined) ? false : force_linewrap;\r\n\r\n            // Never wrap the first token on a line\r\n            if (output.just_added_newline()) {\r\n                return\r\n            }\r\n\r\n            if ((opt.preserve_newlines && current_token.wanted_newline) || force_linewrap) {\r\n                print_newline(false, true);\r\n            } else if (opt.wrap_line_length) {\r\n                var proposed_line_length = output.current_line.get_character_count() + current_token.text.length +\r\n                    (output.space_before_token ? 1 : 0);\r\n                if (proposed_line_length >= opt.wrap_line_length) {\r\n                    print_newline(false, true);\r\n                }\r\n            }\r\n        }\r\n\r\n        function print_newline(force_newline, preserve_statement_flags) {\r\n            if (!preserve_statement_flags) {\r\n                if (flags.last_text !== ';' && flags.last_text !== ',' && flags.last_text !== '=' && last_type !== 'TK_OPERATOR') {\r\n                    while (flags.mode === MODE.Statement && !flags.if_block && !flags.do_block) {\r\n                        restore_mode();\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (output.add_new_line(force_newline)) {\r\n                flags.multiline_frame = true;\r\n            }\r\n        }\r\n\r\n        function print_token_line_indentation() {\r\n            if (output.just_added_newline()) {\r\n                if (opt.keep_array_indentation && is_array(flags.mode) && current_token.wanted_newline) {\r\n                    output.current_line.push(current_token.whitespace_before);\r\n                    output.space_before_token = false;\r\n                } else if (output.set_indent(flags.indentation_level)) {\r\n                    flags.line_indent_level = flags.indentation_level;\r\n                }\r\n            }\r\n        }\r\n\r\n        function print_token(printable_token) {\r\n            printable_token = printable_token || current_token.text;\r\n            print_token_line_indentation();\r\n            output.add_token(printable_token);\r\n        }\r\n\r\n        function indent() {\r\n            flags.indentation_level += 1;\r\n        }\r\n\r\n        function deindent() {\r\n            if (flags.indentation_level > 0 &&\r\n                ((!flags.parent) || flags.indentation_level > flags.parent.indentation_level))\r\n                flags.indentation_level -= 1;\r\n        }\r\n\r\n        function set_mode(mode) {\r\n            if (flags) {\r\n                flag_store.push(flags);\r\n                previous_flags = flags;\r\n            } else {\r\n                previous_flags = create_flags(null, mode);\r\n            }\r\n\r\n            flags = create_flags(previous_flags, mode);\r\n        }\r\n\r\n        function is_array(mode) {\r\n            return mode === MODE.ArrayLiteral;\r\n        }\r\n\r\n        function is_expression(mode) {\r\n            return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);\r\n        }\r\n\r\n        function restore_mode() {\r\n            if (flag_store.length > 0) {\r\n                previous_flags = flags;\r\n                flags = flag_store.pop();\r\n                if (previous_flags.mode === MODE.Statement) {\r\n                    output.remove_redundant_indentation(previous_flags);\r\n                }\r\n            }\r\n        }\r\n\r\n        function start_of_object_property() {\r\n            return flags.parent.mode === MODE.ObjectLiteral && flags.mode === MODE.Statement && (\r\n                (flags.last_text === ':' && flags.ternary_depth === 0) || (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set'])));\r\n        }\r\n\r\n        function start_of_statement() {\r\n            if (\r\n                    (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && current_token.type === 'TK_WORD') ||\r\n                    (last_type === 'TK_RESERVED' && flags.last_text === 'do') ||\r\n                    (last_type === 'TK_RESERVED' && flags.last_text === 'return' && !current_token.wanted_newline) ||\r\n                    (last_type === 'TK_RESERVED' && flags.last_text === 'else' && !(current_token.type === 'TK_RESERVED' && current_token.text === 'if')) ||\r\n                    (last_type === 'TK_END_EXPR' && (previous_flags.mode === MODE.ForInitializer || previous_flags.mode === MODE.Conditional)) ||\r\n                    (last_type === 'TK_WORD' && flags.mode === MODE.BlockStatement\r\n                        && !flags.in_case\r\n                        && !(current_token.text === '--' || current_token.text === '++')\r\n                        && current_token.type !== 'TK_WORD' && current_token.type !== 'TK_RESERVED') ||\r\n                    (flags.mode === MODE.ObjectLiteral && (\r\n                        (flags.last_text === ':' && flags.ternary_depth === 0) || (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set']))))\r\n                ) {\r\n\r\n                set_mode(MODE.Statement);\r\n                indent();\r\n\r\n                if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const']) && current_token.type === 'TK_WORD') {\r\n                    flags.declaration_statement = true;\r\n                }\r\n\r\n                // Issue #276:\r\n                // If starting a new statement with [if, for, while, do], push to a new line.\r\n                // if (a) if (b) if(c) d(); else e(); else f();\r\n                if (!start_of_object_property()) {\r\n                    allow_wrap_or_preserved_newline(\r\n                        current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['do', 'for', 'if', 'while']));\r\n                }\r\n\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n\r\n        function all_lines_start_with(lines, c) {\r\n            for (var i = 0; i < lines.length; i++) {\r\n                var line = trim(lines[i]);\r\n                if (line.charAt(0) !== c) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        function each_line_matches_indent(lines, indent) {\r\n            var i = 0,\r\n                len = lines.length,\r\n                line;\r\n            for (; i < len; i++) {\r\n                line = lines[i];\r\n                // allow empty lines to pass through\r\n                if (line && line.indexOf(indent) !== 0) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        function is_special_word(word) {\r\n            return in_array(word, ['case', 'return', 'do', 'if', 'throw', 'else']);\r\n        }\r\n\r\n        function get_token(offset) {\r\n            var index = token_pos + (offset || 0);\r\n            return (index < 0 || index >= tokens.length) ? null : tokens[index];\r\n        }\r\n\r\n        function handle_start_expr() {\r\n            if (start_of_statement()) {\r\n                // The conditional starts the statement if appropriate.\r\n            }\r\n\r\n            var next_mode = MODE.Expression;\r\n            if (current_token.text === '[') {\r\n\r\n                if (last_type === 'TK_WORD' || flags.last_text === ')') {\r\n                    // this is array index specifier, break immediately\r\n                    // a[x], fn()[x]\r\n                    if (last_type === 'TK_RESERVED' && in_array(flags.last_text, Tokenizer.line_starters)) {\r\n                        output.space_before_token = true;\r\n                    }\r\n                    set_mode(next_mode);\r\n                    print_token();\r\n                    indent();\r\n                    if (opt.space_in_paren) {\r\n                        output.space_before_token = true;\r\n                    }\r\n                    return;\r\n                }\r\n\r\n                next_mode = MODE.ArrayLiteral;\r\n                if (is_array(flags.mode)) {\r\n                    if (flags.last_text === '[' ||\r\n                        (flags.last_text === ',' && (last_last_text === ']' || last_last_text === '}'))) {\r\n                        // ], [ goes to new line\r\n                        // }, [ goes to new line\r\n                        if (!opt.keep_array_indentation) {\r\n                            print_newline();\r\n                        }\r\n                    }\r\n                }\r\n\r\n            } else {\r\n                if (last_type === 'TK_RESERVED' && flags.last_text === 'for') {\r\n                    next_mode = MODE.ForInitializer;\r\n                } else if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['if', 'while'])) {\r\n                    next_mode = MODE.Conditional;\r\n                } else {\r\n                    // next_mode = MODE.Expression;\r\n                }\r\n            }\r\n\r\n            if (flags.last_text === ';' || last_type === 'TK_START_BLOCK') {\r\n                print_newline();\r\n            } else if (last_type === 'TK_END_EXPR' || last_type === 'TK_START_EXPR' || last_type === 'TK_END_BLOCK' || flags.last_text === '.') {\r\n                // TODO: Consider whether forcing this is required.  Review failing tests when removed.\r\n                allow_wrap_or_preserved_newline(current_token.wanted_newline);\r\n                // do nothing on (( and )( and ][ and ]( and .(\r\n            } else if (!(last_type === 'TK_RESERVED' && current_token.text === '(') && last_type !== 'TK_WORD' && last_type !== 'TK_OPERATOR') {\r\n                output.space_before_token = true;\r\n            } else if ((last_type === 'TK_RESERVED' && (flags.last_word === 'function' || flags.last_word === 'typeof')) ||\r\n                (flags.last_text === '*' && last_last_text === 'function')) {\r\n                // function() vs function ()\r\n                if (opt.space_after_anon_function) {\r\n                    output.space_before_token = true;\r\n                }\r\n            } else if (last_type === 'TK_RESERVED' && (in_array(flags.last_text, Tokenizer.line_starters) || flags.last_text === 'catch')) {\r\n                if (opt.space_before_conditional) {\r\n                    output.space_before_token = true;\r\n                }\r\n            }\r\n\r\n            // Support of this kind of newline preservation.\r\n            // a = (b &&\r\n            //     (c || d));\r\n            if (current_token.text === '(') {\r\n                if (last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {\r\n                    if (!start_of_object_property()) {\r\n                        allow_wrap_or_preserved_newline();\r\n                    }\r\n                }\r\n            }\r\n\r\n            set_mode(next_mode);\r\n            print_token();\r\n            if (opt.space_in_paren) {\r\n                output.space_before_token = true;\r\n            }\r\n\r\n            // In all cases, if we newline while inside an expression it should be indented.\r\n            indent();\r\n        }\r\n\r\n        function handle_end_expr() {\r\n            // statements inside expressions are not valid syntax, but...\r\n            // statements must all be closed when their container closes\r\n            while (flags.mode === MODE.Statement) {\r\n                restore_mode();\r\n            }\r\n\r\n            if (flags.multiline_frame) {\r\n                allow_wrap_or_preserved_newline(current_token.text === ']' && is_array(flags.mode) && !opt.keep_array_indentation);\r\n            }\r\n\r\n            if (opt.space_in_paren) {\r\n                if (last_type === 'TK_START_EXPR' && ! opt.space_in_empty_paren) {\r\n                    // () [] no inner space in empty parens like these, ever, ref #320\r\n                    output.trim();\r\n                    output.space_before_token = false;\r\n                } else {\r\n                    output.space_before_token = true;\r\n                }\r\n            }\r\n            if (current_token.text === ']' && opt.keep_array_indentation) {\r\n                print_token();\r\n                restore_mode();\r\n            } else {\r\n                restore_mode();\r\n                print_token();\r\n            }\r\n            output.remove_redundant_indentation(previous_flags);\r\n\r\n            // do {} while () // no statement required after\r\n            if (flags.do_while && previous_flags.mode === MODE.Conditional) {\r\n                previous_flags.mode = MODE.Expression;\r\n                flags.do_block = false;\r\n                flags.do_while = false;\r\n\r\n            }\r\n        }\r\n\r\n        function handle_start_block() {\r\n            // Check if this is should be treated as a ObjectLiteral\r\n            var next_token = get_token(1)\r\n            var second_token = get_token(2)\r\n            if (second_token && (\r\n                    (second_token.text === ':' && in_array(next_token.type, ['TK_STRING', 'TK_WORD', 'TK_RESERVED']))\r\n                    || (in_array(next_token.text, ['get', 'set']) && in_array(second_token.type, ['TK_WORD', 'TK_RESERVED']))\r\n                )) {\r\n                // We don't support TypeScript,but we didn't break it for a very long time.\r\n                // We'll try to keep not breaking it.\r\n                if (!in_array(last_last_text, ['class','interface'])) {\r\n                    set_mode(MODE.ObjectLiteral);\r\n                } else {\r\n                    set_mode(MODE.BlockStatement);\r\n                }\r\n            } else {\r\n                set_mode(MODE.BlockStatement);\r\n            }\r\n\r\n            var empty_braces = !next_token.comments_before.length &&  next_token.text === '}';\r\n            var empty_anonymous_function = empty_braces && flags.last_word === 'function' &&\r\n                last_type === 'TK_END_EXPR';\r\n\r\n            if (opt.brace_style === \"expand\" ||\r\n                (opt.brace_style === \"none\" && current_token.wanted_newline)) {\r\n                if (last_type !== 'TK_OPERATOR' &&\r\n                    (empty_anonymous_function ||\r\n                        last_type === 'TK_EQUALS' ||\r\n                        (last_type === 'TK_RESERVED' && is_special_word(flags.last_text) && flags.last_text !== 'else'))) {\r\n                    output.space_before_token = true;\r\n                } else {\r\n                    print_newline(false, true);\r\n                }\r\n            } else { // collapse\r\n                if (last_type !== 'TK_OPERATOR' && last_type !== 'TK_START_EXPR') {\r\n                    if (last_type === 'TK_START_BLOCK') {\r\n                        print_newline();\r\n                    } else {\r\n                        output.space_before_token = true;\r\n                    }\r\n                } else {\r\n                    // if TK_OPERATOR or TK_START_EXPR\r\n                    if (is_array(previous_flags.mode) && flags.last_text === ',') {\r\n                        if (last_last_text === '}') {\r\n                            // }, { in array context\r\n                            output.space_before_token = true;\r\n                        } else {\r\n                            print_newline(); // [a, b, c, {\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            print_token();\r\n            indent();\r\n        }\r\n\r\n        function handle_end_block() {\r\n            // statements must all be closed when their container closes\r\n            while (flags.mode === MODE.Statement) {\r\n                restore_mode();\r\n            }\r\n            var empty_braces = last_type === 'TK_START_BLOCK';\r\n\r\n            if (opt.brace_style === \"expand\") {\r\n                if (!empty_braces) {\r\n                    print_newline();\r\n                }\r\n            } else {\r\n                // skip {}\r\n                if (!empty_braces) {\r\n                    if (is_array(flags.mode) && opt.keep_array_indentation) {\r\n                        // we REALLY need a newline here, but newliner would skip that\r\n                        opt.keep_array_indentation = false;\r\n                        print_newline();\r\n                        opt.keep_array_indentation = true;\r\n\r\n                    } else {\r\n                        print_newline();\r\n                    }\r\n                }\r\n            }\r\n            restore_mode();\r\n            print_token();\r\n        }\r\n\r\n        function handle_word() {\r\n            if (current_token.type === 'TK_RESERVED' && flags.mode !== MODE.ObjectLiteral &&\r\n                in_array(current_token.text, ['set', 'get'])) {\r\n                current_token.type = 'TK_WORD';\r\n            }\r\n\r\n            if (current_token.type === 'TK_RESERVED' && flags.mode === MODE.ObjectLiteral) {\r\n                var next_token = get_token(1);\r\n                if (next_token.text == ':') {\r\n                    current_token.type = 'TK_WORD';\r\n                }\r\n            }\r\n\r\n            if (start_of_statement()) {\r\n                // The conditional starts the statement if appropriate.\r\n            } else if (current_token.wanted_newline && !is_expression(flags.mode) &&\r\n                (last_type !== 'TK_OPERATOR' || (flags.last_text === '--' || flags.last_text === '++')) &&\r\n                last_type !== 'TK_EQUALS' &&\r\n                (opt.preserve_newlines || !(last_type === 'TK_RESERVED' && in_array(flags.last_text, ['var', 'let', 'const', 'set', 'get'])))) {\r\n\r\n                print_newline();\r\n            }\r\n\r\n            if (flags.do_block && !flags.do_while) {\r\n                if (current_token.type === 'TK_RESERVED' && current_token.text === 'while') {\r\n                    // do {} ## while ()\r\n                    output.space_before_token = true;\r\n                    print_token();\r\n                    output.space_before_token = true;\r\n                    flags.do_while = true;\r\n                    return;\r\n                } else {\r\n                    // do {} should always have while as the next word.\r\n                    // if we don't see the expected while, recover\r\n                    print_newline();\r\n                    flags.do_block = false;\r\n                }\r\n            }\r\n\r\n            // if may be followed by else, or not\r\n            // Bare/inline ifs are tricky\r\n            // Need to unwind the modes correctly: if (a) if (b) c(); else d(); else e();\r\n            if (flags.if_block) {\r\n                if (!flags.else_block && (current_token.type === 'TK_RESERVED' && current_token.text === 'else')) {\r\n                    flags.else_block = true;\r\n                } else {\r\n                    while (flags.mode === MODE.Statement) {\r\n                        restore_mode();\r\n                    }\r\n                    flags.if_block = false;\r\n                    flags.else_block = false;\r\n                }\r\n            }\r\n\r\n            if (current_token.type === 'TK_RESERVED' && (current_token.text === 'case' || (current_token.text === 'default' && flags.in_case_statement))) {\r\n                print_newline();\r\n                if (flags.case_body || opt.jslint_happy) {\r\n                    // switch cases following one another\r\n                    deindent();\r\n                    flags.case_body = false;\r\n                }\r\n                print_token();\r\n                flags.in_case = true;\r\n                flags.in_case_statement = true;\r\n                return;\r\n            }\r\n\r\n            if (current_token.type === 'TK_RESERVED' && current_token.text === 'function') {\r\n                if (in_array(flags.last_text, ['}', ';']) || (output.just_added_newline() && ! in_array(flags.last_text, ['[', '{', ':', '=', ',']))) {\r\n                    // make sure there is a nice clean space of at least one blank line\r\n                    // before a new function definition\r\n                    if ( !output.just_added_blankline() && !current_token.comments_before.length) {\r\n                        print_newline();\r\n                        print_newline(true);\r\n                    }\r\n                }\r\n                if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {\r\n                    if (last_type === 'TK_RESERVED' && in_array(flags.last_text, ['get', 'set', 'new', 'return', 'export'])) {\r\n                        output.space_before_token = true;\r\n                    } else if (last_type === 'TK_RESERVED' && flags.last_text === 'default' && last_last_text === 'export') {\r\n                        output.space_before_token = true;\r\n                    } else {\r\n                        print_newline();\r\n                    }\r\n                } else if (last_type === 'TK_OPERATOR' || flags.last_text === '=') {\r\n                    // foo = function\r\n                    output.space_before_token = true;\r\n                } else if (!flags.multiline_frame && (is_expression(flags.mode) || is_array(flags.mode))) {\r\n                    // (function\r\n                } else {\r\n                    print_newline();\r\n                }\r\n            }\r\n\r\n            if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {\r\n                if (!start_of_object_property()) {\r\n                    allow_wrap_or_preserved_newline();\r\n                }\r\n            }\r\n\r\n            if (current_token.type === 'TK_RESERVED' &&  in_array(current_token.text, ['function', 'get', 'set'])) {\r\n                print_token();\r\n                flags.last_word = current_token.text;\r\n                return;\r\n            }\r\n\r\n            prefix = 'NONE';\r\n\r\n            if (last_type === 'TK_END_BLOCK') {\r\n                if (!(current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['else', 'catch', 'finally']))) {\r\n                    prefix = 'NEWLINE';\r\n                } else {\r\n                    if (opt.brace_style === \"expand\" ||\r\n                        opt.brace_style === \"end-expand\" ||\r\n                        (opt.brace_style === \"none\" && current_token.wanted_newline)) {\r\n                        prefix = 'NEWLINE';\r\n                    } else {\r\n                        prefix = 'SPACE';\r\n                        output.space_before_token = true;\r\n                    }\r\n                }\r\n            } else if (last_type === 'TK_SEMICOLON' && flags.mode === MODE.BlockStatement) {\r\n                // TODO: Should this be for STATEMENT as well?\r\n                prefix = 'NEWLINE';\r\n            } else if (last_type === 'TK_SEMICOLON' && is_expression(flags.mode)) {\r\n                prefix = 'SPACE';\r\n            } else if (last_type === 'TK_STRING') {\r\n                prefix = 'NEWLINE';\r\n            } else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD' ||\r\n                (flags.last_text === '*' && last_last_text === 'function')) {\r\n                prefix = 'SPACE';\r\n            } else if (last_type === 'TK_START_BLOCK') {\r\n                prefix = 'NEWLINE';\r\n            } else if (last_type === 'TK_END_EXPR') {\r\n                output.space_before_token = true;\r\n                prefix = 'NEWLINE';\r\n            }\r\n\r\n            if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, Tokenizer.line_starters) && flags.last_text !== ')') {\r\n                if (flags.last_text === 'else' || flags.last_text === 'export') {\r\n                    prefix = 'SPACE';\r\n                } else {\r\n                    prefix = 'NEWLINE';\r\n                }\r\n\r\n            }\r\n\r\n            if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['else', 'catch', 'finally'])) {\r\n                if (last_type !== 'TK_END_BLOCK' ||\r\n                    opt.brace_style === \"expand\" ||\r\n                    opt.brace_style === \"end-expand\" ||\r\n                    (opt.brace_style === \"none\" && current_token.wanted_newline)) {\r\n                    print_newline();\r\n                } else {\r\n                    output.trim(true);\r\n                    var line = output.current_line;\r\n                    // If we trimmed and there's something other than a close block before us\r\n                    // put a newline back in.  Handles '} // comment' scenario.\r\n                    if (line.last() !== '}') {\r\n                        print_newline();\r\n                    }\r\n                    output.space_before_token = true;\r\n                }\r\n            } else if (prefix === 'NEWLINE') {\r\n                if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {\r\n                    // no newline between 'return nnn'\r\n                    output.space_before_token = true;\r\n                } else if (last_type !== 'TK_END_EXPR') {\r\n                    if ((last_type !== 'TK_START_EXPR' || !(current_token.type === 'TK_RESERVED' && in_array(current_token.text, ['var', 'let', 'const']))) && flags.last_text !== ':') {\r\n                        // no need to force newline on 'var': for (var x = 0...)\r\n                        if (current_token.type === 'TK_RESERVED' && current_token.text === 'if' && flags.last_text === 'else') {\r\n                            // no newline for } else if {\r\n                            output.space_before_token = true;\r\n                        } else {\r\n                            print_newline();\r\n                        }\r\n                    }\r\n                } else if (current_token.type === 'TK_RESERVED' && in_array(current_token.text, Tokenizer.line_starters) && flags.last_text !== ')') {\r\n                    print_newline();\r\n                }\r\n            } else if (flags.multiline_frame && is_array(flags.mode) && flags.last_text === ',' && last_last_text === '}') {\r\n                print_newline(); // }, in lists get a newline treatment\r\n            } else if (prefix === 'SPACE') {\r\n                output.space_before_token = true;\r\n            }\r\n            print_token();\r\n            flags.last_word = current_token.text;\r\n\r\n            if (current_token.type === 'TK_RESERVED' && current_token.text === 'do') {\r\n                flags.do_block = true;\r\n            }\r\n\r\n            if (current_token.type === 'TK_RESERVED' && current_token.text === 'if') {\r\n                flags.if_block = true;\r\n            }\r\n        }\r\n\r\n        function handle_semicolon() {\r\n            if (start_of_statement()) {\r\n                // The conditional starts the statement if appropriate.\r\n                // Semicolon can be the start (and end) of a statement\r\n                output.space_before_token = false;\r\n            }\r\n            while (flags.mode === MODE.Statement && !flags.if_block && !flags.do_block) {\r\n                restore_mode();\r\n            }\r\n            print_token();\r\n        }\r\n\r\n        function handle_string() {\r\n            if (start_of_statement()) {\r\n                // The conditional starts the statement if appropriate.\r\n                // One difference - strings want at least a space before\r\n                output.space_before_token = true;\r\n            } else if (last_type === 'TK_RESERVED' || last_type === 'TK_WORD') {\r\n                output.space_before_token = true;\r\n            } else if (last_type === 'TK_COMMA' || last_type === 'TK_START_EXPR' || last_type === 'TK_EQUALS' || last_type === 'TK_OPERATOR') {\r\n                if (!start_of_object_property()) {\r\n                    allow_wrap_or_preserved_newline();\r\n                }\r\n            } else {\r\n                print_newline();\r\n            }\r\n            print_token();\r\n        }\r\n\r\n        function handle_equals() {\r\n            if (start_of_statement()) {\r\n                // The conditional starts the statement if appropriate.\r\n            }\r\n\r\n            if (flags.declaration_statement) {\r\n                // just got an '=' in a var-line, different formatting/line-breaking, etc will now be done\r\n                flags.declaration_assignment = true;\r\n            }\r\n            output.space_before_token = true;\r\n            print_token();\r\n            output.space_before_token = true;\r\n        }\r\n\r\n        function handle_comma() {\r\n            if (flags.declaration_statement) {\r\n                if (is_expression(flags.parent.mode)) {\r\n                    // do not break on comma, for(var a = 1, b = 2)\r\n                    flags.declaration_assignment = false;\r\n                }\r\n\r\n                print_token();\r\n\r\n                if (flags.declaration_assignment) {\r\n                    flags.declaration_assignment = false;\r\n                    print_newline(false, true);\r\n                } else {\r\n                    output.space_before_token = true;\r\n                }\r\n                return;\r\n            }\r\n\r\n            print_token();\r\n            if (flags.mode === MODE.ObjectLiteral ||\r\n                (flags.mode === MODE.Statement && flags.parent.mode === MODE.ObjectLiteral)) {\r\n                if (flags.mode === MODE.Statement) {\r\n                    restore_mode();\r\n                }\r\n                print_newline();\r\n            } else {\r\n                // EXPR or DO_BLOCK\r\n                output.space_before_token = true;\r\n            }\r\n\r\n        }\r\n\r\n        function handle_operator() {\r\n            if (start_of_statement()) {\r\n                // The conditional starts the statement if appropriate.\r\n            }\r\n\r\n            if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {\r\n                // \"return\" had a special handling in TK_WORD. Now we need to return the favor\r\n                output.space_before_token = true;\r\n                print_token();\r\n                return;\r\n            }\r\n\r\n            // hack for actionscript's import .*;\r\n            if (current_token.text === '*' && last_type === 'TK_DOT') {\r\n                print_token();\r\n                return;\r\n            }\r\n\r\n            if (current_token.text === ':' && flags.in_case) {\r\n                flags.case_body = true;\r\n                indent();\r\n                print_token();\r\n                print_newline();\r\n                flags.in_case = false;\r\n                return;\r\n            }\r\n\r\n            if (current_token.text === '::') {\r\n                // no spaces around exotic namespacing syntax operator\r\n                print_token();\r\n                return;\r\n            }\r\n\r\n            // http://www.ecma-international.org/ecma-262/5.1/#sec-7.9.1\r\n            // if there is a newline between -- or ++ and anything else we should preserve it.\r\n            if (current_token.wanted_newline && (current_token.text === '--' || current_token.text === '++')) {\r\n                print_newline(false, true);\r\n            }\r\n\r\n            // Allow line wrapping between operators\r\n            if (last_type === 'TK_OPERATOR') {\r\n                allow_wrap_or_preserved_newline();\r\n            }\r\n\r\n            var space_before = true;\r\n            var space_after = true;\r\n\r\n            if (in_array(current_token.text, ['--', '++', '!', '~']) || (in_array(current_token.text, ['-', '+']) && (in_array(last_type, ['TK_START_BLOCK', 'TK_START_EXPR', 'TK_EQUALS', 'TK_OPERATOR']) || in_array(flags.last_text, Tokenizer.line_starters) || flags.last_text === ','))) {\r\n                // unary operators (and binary +/- pretending to be unary) special cases\r\n\r\n                space_before = false;\r\n                space_after = false;\r\n\r\n                if (flags.last_text === ';' && is_expression(flags.mode)) {\r\n                    // for (;; ++i)\r\n                    //        ^^^\r\n                    space_before = true;\r\n                }\r\n\r\n                if (last_type === 'TK_RESERVED' || last_type === 'TK_END_EXPR') {\r\n                    space_before = true;\r\n                } else if (last_type === 'TK_OPERATOR') {\r\n                    space_before =\r\n                        (in_array(current_token.text, ['--', '-']) && in_array(flags.last_text, ['--', '-'])) ||\r\n                        (in_array(current_token.text, ['++', '+']) && in_array(flags.last_text, ['++', '+']));\r\n                }\r\n\r\n                if ((flags.mode === MODE.BlockStatement || flags.mode === MODE.Statement) && (flags.last_text === '{' || flags.last_text === ';')) {\r\n                    // { foo; --i }\r\n                    // foo(); --bar;\r\n                    print_newline();\r\n                }\r\n            } else if (current_token.text === ':') {\r\n                if (flags.ternary_depth === 0) {\r\n                    // Colon is invalid javascript outside of ternary and object, but do our best to guess what was meant.\r\n                    space_before = false;\r\n                } else {\r\n                    flags.ternary_depth -= 1;\r\n                }\r\n            } else if (current_token.text === '?') {\r\n                flags.ternary_depth += 1;\r\n            } else if (current_token.text === '*' && last_type === 'TK_RESERVED' && flags.last_text === 'function') {\r\n                space_before = false;\r\n                space_after = false;\r\n            }\r\n            output.space_before_token = output.space_before_token || space_before;\r\n            print_token();\r\n            output.space_before_token = space_after;\r\n        }\r\n\r\n        function handle_block_comment() {\r\n            var lines = split_newlines(current_token.text);\r\n            var j; // iterator for this case\r\n            var javadoc = false;\r\n            var starless = false;\r\n            var lastIndent = current_token.whitespace_before;\r\n            var lastIndentLength = lastIndent.length;\r\n\r\n            // block comment starts with a new line\r\n            print_newline(false, true);\r\n            if (lines.length > 1) {\r\n                if (all_lines_start_with(lines.slice(1), '*')) {\r\n                    javadoc = true;\r\n                }\r\n                else if (each_line_matches_indent(lines.slice(1), lastIndent)) {\r\n                    starless = true;\r\n                }\r\n            }\r\n\r\n            // first line always indented\r\n            print_token(lines[0]);\r\n            for (j = 1; j < lines.length; j++) {\r\n                print_newline(false, true);\r\n                if (javadoc) {\r\n                    // javadoc: reformat and re-indent\r\n                    print_token(' ' + trim(lines[j]));\r\n                } else if (starless && lines[j].length > lastIndentLength) {\r\n                    // starless: re-indent non-empty content, avoiding trim\r\n                    print_token(lines[j].substring(lastIndentLength));\r\n                } else {\r\n                    // normal comments output raw\r\n                    output.add_token(lines[j]);\r\n                }\r\n            }\r\n\r\n            // for comments of more than one line, make sure there's a new line after\r\n            print_newline(false, true);\r\n        }\r\n\r\n        function handle_inline_comment() {\r\n            output.space_before_token = true;\r\n            print_token();\r\n            output.space_before_token = true;\r\n        }\r\n\r\n        function handle_comment() {\r\n            if (current_token.wanted_newline) {\r\n                print_newline(false, true);\r\n            } else {\r\n                output.trim(true);\r\n            }\r\n\r\n            output.space_before_token = true;\r\n            print_token();\r\n            print_newline(false, true);\r\n        }\r\n\r\n        function handle_dot() {\r\n            if (start_of_statement()) {\r\n                // The conditional starts the statement if appropriate.\r\n            }\r\n\r\n            if (last_type === 'TK_RESERVED' && is_special_word(flags.last_text)) {\r\n                output.space_before_token = true;\r\n            } else {\r\n                // allow preserved newlines before dots in general\r\n                // force newlines on dots after close paren when break_chained - for bar().baz()\r\n                allow_wrap_or_preserved_newline(flags.last_text === ')' && opt.break_chained_methods);\r\n            }\r\n\r\n            print_token();\r\n        }\r\n\r\n        function handle_unknown() {\r\n            print_token();\r\n\r\n            if (current_token.text[current_token.text.length - 1] === '\\n') {\r\n                print_newline();\r\n            }\r\n        }\r\n\r\n        function handle_eof() {\r\n            // Unwind any open statements\r\n            while (flags.mode === MODE.Statement) {\r\n                restore_mode();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    function OutputLine(parent) {\r\n        var _character_count = 0;\r\n        // use indent_count as a marker for lines that have preserved indentation\r\n        var _indent_count = -1;\r\n\r\n        var _items = [];\r\n        var _empty = true;\r\n\r\n        this.set_indent = function(level) {\r\n            _character_count = parent.baseIndentLength + level * parent.indent_length\r\n            _indent_count = level;\r\n        }\r\n\r\n        this.get_character_count = function() {\r\n            return _character_count;\r\n        }\r\n\r\n        this.is_empty = function() {\r\n            return _empty;\r\n        }\r\n\r\n        this.last = function() {\r\n            if (!this._empty) {\r\n              return _items[_items.length - 1];\r\n            } else {\r\n              return null;\r\n            }\r\n        }\r\n\r\n        this.push = function(input) {\r\n            _items.push(input);\r\n            _character_count += input.length;\r\n            _empty = false;\r\n        }\r\n\r\n        this.remove_indent = function() {\r\n            if (_indent_count > 0) {\r\n                _indent_count -= 1;\r\n                _character_count -= parent.indent_length\r\n            }\r\n        }\r\n\r\n        this.trim = function() {\r\n            while (this.last() === ' ') {\r\n                var item = _items.pop();\r\n                _character_count -= 1;\r\n            }\r\n            _empty = _items.length === 0;\r\n        }\r\n\r\n        this.toString = function() {\r\n            var result = '';\r\n            if (!this._empty) {\r\n                if (_indent_count >= 0) {\r\n                    result = parent.indent_cache[_indent_count];\r\n                }\r\n                result += _items.join('')\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n\r\n    function Output(indent_string, baseIndentString) {\r\n        baseIndentString = baseIndentString || '';\r\n        this.indent_cache = [ baseIndentString ];\r\n        this.baseIndentLength = baseIndentString.length;\r\n        this.indent_length = indent_string.length;\r\n\r\n        var lines =[];\r\n        this.baseIndentString = baseIndentString;\r\n        this.indent_string = indent_string;\r\n        this.current_line = null;\r\n        this.space_before_token = false;\r\n\r\n        this.get_line_number = function() {\r\n            return lines.length;\r\n        }\r\n\r\n        // Using object instead of string to allow for later expansion of info about each line\r\n        this.add_new_line = function(force_newline) {\r\n            if (this.get_line_number() === 1 && this.just_added_newline()) {\r\n                return false; // no newline on start of file\r\n            }\r\n\r\n            if (force_newline || !this.just_added_newline()) {\r\n                this.current_line = new OutputLine(this);\r\n                lines.push(this.current_line);\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n\r\n        // initialize\r\n        this.add_new_line(true);\r\n\r\n        this.get_code = function() {\r\n            var sweet_code = lines.join('\\n').replace(/[\\r\\n\\t ]+$/, '');\r\n            return sweet_code;\r\n        }\r\n\r\n        this.set_indent = function(level) {\r\n            // Never indent your first output indent at the start of the file\r\n            if (lines.length > 1) {\r\n                while(level >= this.indent_cache.length) {\r\n                    this.indent_cache.push(this.indent_cache[this.indent_cache.length - 1] + this.indent_string);\r\n                }\r\n\r\n                this.current_line.set_indent(level);\r\n                return true;\r\n            }\r\n            this.current_line.set_indent(0);\r\n            return false;\r\n        }\r\n\r\n        this.add_token = function(printable_token) {\r\n            this.add_space_before_token();\r\n            this.current_line.push(printable_token);\r\n        }\r\n\r\n        this.add_space_before_token = function() {\r\n            if (this.space_before_token && !this.just_added_newline()) {\r\n                this.current_line.push(' ');\r\n            }\r\n            this.space_before_token = false;\r\n        }\r\n\r\n        this.remove_redundant_indentation = function (frame) {\r\n            // This implementation is effective but has some issues:\r\n            //     - can cause line wrap to happen too soon due to indent removal\r\n            //           after wrap points are calculated\r\n            // These issues are minor compared to ugly indentation.\r\n\r\n            if (frame.multiline_frame ||\r\n                frame.mode === MODE.ForInitializer ||\r\n                frame.mode === MODE.Conditional) {\r\n                return;\r\n            }\r\n\r\n            // remove one indent from each line inside this section\r\n            var index = frame.start_line_index;\r\n            var line;\r\n\r\n            var output_length = lines.length;\r\n            while (index < output_length) {\r\n                lines[index].remove_indent();\r\n                index++;\r\n            }\r\n        }\r\n\r\n        this.trim = function(eat_newlines) {\r\n            eat_newlines = (eat_newlines === undefined) ? false : eat_newlines;\r\n\r\n            this.current_line.trim(indent_string, baseIndentString);\r\n\r\n            while (eat_newlines && lines.length > 1 &&\r\n                this.current_line.is_empty()) {\r\n                lines.pop();\r\n                this.current_line = lines[lines.length - 1]\r\n                this.current_line.trim();\r\n            }\r\n        }\r\n\r\n        this.just_added_newline = function() {\r\n            return this.current_line.is_empty();\r\n        }\r\n\r\n        this.just_added_blankline = function() {\r\n            if (this.just_added_newline()) {\r\n                if (lines.length === 1) {\r\n                    return true; // start of the file and newline = blank\r\n                }\r\n\r\n                var line = lines[lines.length - 2];\r\n                return line.is_empty();\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n\r\n\r\n    var Token = function(type, text, newlines, whitespace_before, mode, parent) {\r\n        this.type = type;\r\n        this.text = text;\r\n        this.comments_before = [];\r\n        this.newlines = newlines || 0;\r\n        this.wanted_newline = newlines > 0;\r\n        this.whitespace_before = whitespace_before || '';\r\n        this.parent = null;\r\n    }\r\n\r\n    function tokenizer(input, opts, indent_string) {\r\n\r\n        var whitespace = \"\\n\\r\\t \".split('');\r\n        var digit = /[0-9]/;\r\n\r\n        var punct = ('+ - * / % & ++ -- = += -= *= /= %= == === != !== > < >= <= >> << >>> >>>= >>= <<= && &= | || ! ~ , : ? ^ ^= |= :: =>'\r\n                +' <%= <% %> <?= <? ?>').split(' '); // try to be a good boy and try not to break the markup language identifiers\r\n\r\n        // words which should always start on new line.\r\n        this.line_starters = 'continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,yield,import,export'.split(',');\r\n        var reserved_words = this.line_starters.concat(['do', 'in', 'else', 'get', 'set', 'new', 'catch', 'finally', 'typeof']);\r\n\r\n        var n_newlines, whitespace_before_token, in_html_comment, tokens, parser_pos;\r\n        var input_length;\r\n\r\n        this.tokenize = function() {\r\n            // cache the source's length.\r\n            input_length = input.length\r\n            parser_pos = 0;\r\n            in_html_comment = false\r\n            tokens = [];\r\n\r\n            var next, last;\r\n            var token_values;\r\n            var open = null;\r\n            var open_stack = [];\r\n            var comments = [];\r\n\r\n            while (!(last && last.type === 'TK_EOF')) {\r\n                token_values = tokenize_next();\r\n                next = new Token(token_values[1], token_values[0], n_newlines, whitespace_before_token);\r\n                while(next.type === 'TK_INLINE_COMMENT' || next.type === 'TK_COMMENT' ||\r\n                    next.type === 'TK_BLOCK_COMMENT' || next.type === 'TK_UNKNOWN') {\r\n                    comments.push(next);\r\n                    token_values = tokenize_next();\r\n                    next = new Token(token_values[1], token_values[0], n_newlines, whitespace_before_token);\r\n                }\r\n\r\n                if (comments.length) {\r\n                    next.comments_before = comments;\r\n                    comments = [];\r\n                }\r\n\r\n                if (next.type === 'TK_START_BLOCK' || next.type === 'TK_START_EXPR') {\r\n                    next.parent = last;\r\n                    open = next;\r\n                    open_stack.push(next);\r\n                }  else if ((next.type === 'TK_END_BLOCK' || next.type === 'TK_END_EXPR') &&\r\n                    (open && (\r\n                        (next.text === ']' && open.text === '[') ||\r\n                        (next.text === ')' && open.text === '(') ||\r\n                        (next.text === '}' && open.text === '}')))) {\r\n                    next.parent = open.parent;\r\n                    open = open_stack.pop();\r\n                }\r\n\r\n                tokens.push(next);\r\n                last = next;\r\n            }\r\n\r\n            return tokens;\r\n        }\r\n\r\n        function tokenize_next() {\r\n            var i, resulting_string;\r\n            var whitespace_on_this_line = [];\r\n\r\n            n_newlines = 0;\r\n            whitespace_before_token = '';\r\n\r\n            if (parser_pos >= input_length) {\r\n                return ['', 'TK_EOF'];\r\n            }\r\n\r\n            var last_token;\r\n            if (tokens.length) {\r\n                last_token = tokens[tokens.length-1];\r\n            } else {\r\n                // For the sake of tokenizing we can pretend that there was on open brace to start\r\n                last_token = new Token('TK_START_BLOCK', '{');\r\n            }\r\n\r\n\r\n            var c = input.charAt(parser_pos);\r\n            parser_pos += 1;\r\n\r\n            while (in_array(c, whitespace)) {\r\n\r\n                if (c === '\\n') {\r\n                    n_newlines += 1;\r\n                    whitespace_on_this_line = [];\r\n                } else if (n_newlines) {\r\n                    if (c === indent_string) {\r\n                        whitespace_on_this_line.push(indent_string);\r\n                    } else if (c !== '\\r') {\r\n                        whitespace_on_this_line.push(' ');\r\n                    }\r\n                }\r\n\r\n                if (parser_pos >= input_length) {\r\n                    return ['', 'TK_EOF'];\r\n                }\r\n\r\n                c = input.charAt(parser_pos);\r\n                parser_pos += 1;\r\n            }\r\n\r\n            if(whitespace_on_this_line.length) {\r\n                whitespace_before_token = whitespace_on_this_line.join('');\r\n            }\r\n\r\n            if (digit.test(c)) {\r\n                var allow_decimal = true;\r\n                var allow_e = true;\r\n                var local_digit = digit;\r\n\r\n                if (c === '0' && parser_pos < input_length && /[Xx]/.test(input.charAt(parser_pos))) {\r\n                    // switch to hex number, no decimal or e, just hex digits\r\n                    allow_decimal = false;\r\n                    allow_e = false;\r\n                    c += input.charAt(parser_pos);\r\n                    parser_pos += 1;\r\n                    local_digit = /[0123456789abcdefABCDEF]/\r\n                } else {\r\n                    // we know this first loop will run.  It keeps the logic simpler.\r\n                    c = '';\r\n                    parser_pos -= 1\r\n                }\r\n\r\n                // Add the digits\r\n                while (parser_pos < input_length && local_digit.test(input.charAt(parser_pos))) {\r\n                    c += input.charAt(parser_pos);\r\n                    parser_pos += 1;\r\n\r\n                    if (allow_decimal && parser_pos < input_length && input.charAt(parser_pos) === '.') {\r\n                        c += input.charAt(parser_pos);\r\n                        parser_pos += 1;\r\n                        allow_decimal = false;\r\n                    }\r\n\r\n                    if (allow_e && parser_pos < input_length && /[Ee]/.test(input.charAt(parser_pos))) {\r\n                        c += input.charAt(parser_pos);\r\n                        parser_pos += 1;\r\n\r\n                        if (parser_pos < input_length && /[+-]/.test(input.charAt(parser_pos))) {\r\n                            c += input.charAt(parser_pos);\r\n                            parser_pos += 1;\r\n                        }\r\n\r\n                        allow_e = false;\r\n                        allow_decimal = false;\r\n                    }\r\n                }\r\n\r\n                return [c, 'TK_WORD'];\r\n            }\r\n\r\n            if (acorn.isIdentifierStart(input.charCodeAt(parser_pos-1))) {\r\n                if (parser_pos < input_length) {\r\n                    while (acorn.isIdentifierChar(input.charCodeAt(parser_pos))) {\r\n                        c += input.charAt(parser_pos);\r\n                        parser_pos += 1;\r\n                        if (parser_pos === input_length) {\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!(last_token.type === 'TK_DOT' ||\r\n                        (last_token.type === 'TK_RESERVED' && in_array(last_token.text, ['set', 'get'])))\r\n                    && in_array(c, reserved_words)) {\r\n                    if (c === 'in') { // hack for 'in' operator\r\n                        return [c, 'TK_OPERATOR'];\r\n                    }\r\n                    return [c, 'TK_RESERVED'];\r\n                }\r\n\r\n                return [c, 'TK_WORD'];\r\n            }\r\n\r\n            if (c === '(' || c === '[') {\r\n                return [c, 'TK_START_EXPR'];\r\n            }\r\n\r\n            if (c === ')' || c === ']') {\r\n                return [c, 'TK_END_EXPR'];\r\n            }\r\n\r\n            if (c === '{') {\r\n                return [c, 'TK_START_BLOCK'];\r\n            }\r\n\r\n            if (c === '}') {\r\n                return [c, 'TK_END_BLOCK'];\r\n            }\r\n\r\n            if (c === ';') {\r\n                return [c, 'TK_SEMICOLON'];\r\n            }\r\n\r\n            if (c === '/') {\r\n                var comment = '';\r\n                // peek for comment /* ... */\r\n                var inline_comment = true;\r\n                if (input.charAt(parser_pos) === '*') {\r\n                    parser_pos += 1;\r\n                    if (parser_pos < input_length) {\r\n                        while (parser_pos < input_length && !(input.charAt(parser_pos) === '*' && input.charAt(parser_pos + 1) && input.charAt(parser_pos + 1) === '/')) {\r\n                            c = input.charAt(parser_pos);\r\n                            comment += c;\r\n                            if (c === \"\\n\" || c === \"\\r\") {\r\n                                inline_comment = false;\r\n                            }\r\n                            parser_pos += 1;\r\n                            if (parser_pos >= input_length) {\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    parser_pos += 2;\r\n                    if (inline_comment && n_newlines === 0) {\r\n                        return ['/*' + comment + '*/', 'TK_INLINE_COMMENT'];\r\n                    } else {\r\n                        return ['/*' + comment + '*/', 'TK_BLOCK_COMMENT'];\r\n                    }\r\n                }\r\n                // peek for comment // ...\r\n                if (input.charAt(parser_pos) === '/') {\r\n                    comment = c;\r\n                    while (input.charAt(parser_pos) !== '\\r' && input.charAt(parser_pos) !== '\\n') {\r\n                        comment += input.charAt(parser_pos);\r\n                        parser_pos += 1;\r\n                        if (parser_pos >= input_length) {\r\n                            break;\r\n                        }\r\n                    }\r\n                    return [comment, 'TK_COMMENT'];\r\n                }\r\n\r\n            }\r\n\r\n            if (c === '`' || c === \"'\" || c === '\"' || // string\r\n                (\r\n                    (c === '/') || // regexp\r\n                    (opts.e4x && c === \"<\" && input.slice(parser_pos - 1).match(/^<([-a-zA-Z:0-9_.]+|{[^{}]*}|!\\[CDATA\\[[\\s\\S]*?\\]\\])\\s*([-a-zA-Z:0-9_.]+=('[^']*'|\"[^\"]*\"|{[^{}]*})\\s*)*\\/?\\s*>/)) // xml\r\n                ) && ( // regex and xml can only appear in specific locations during parsing\r\n                    (last_token.type === 'TK_RESERVED' && in_array(last_token.text , ['return', 'case', 'throw', 'else', 'do', 'typeof', 'yield'])) ||\r\n                    (last_token.type === 'TK_END_EXPR' && last_token.text === ')' &&\r\n                        last_token.parent && last_token.parent.type === 'TK_RESERVED' && in_array(last_token.parent.text, ['if', 'while', 'for'])) ||\r\n                    (in_array(last_token.type, ['TK_COMMENT', 'TK_START_EXPR', 'TK_START_BLOCK',\r\n                        'TK_END_BLOCK', 'TK_OPERATOR', 'TK_EQUALS', 'TK_EOF', 'TK_SEMICOLON', 'TK_COMMA'\r\n                    ]))\r\n                )) {\r\n\r\n                var sep = c,\r\n                    esc = false,\r\n                    has_char_escapes = false;\r\n\r\n                resulting_string = c;\r\n\r\n                if (sep === '/') {\r\n                    //\r\n                    // handle regexp\r\n                    //\r\n                    var in_char_class = false;\r\n                    while (parser_pos < input_length &&\r\n                            ((esc || in_char_class || input.charAt(parser_pos) !== sep) &&\r\n                            !acorn.newline.test(input.charAt(parser_pos)))) {\r\n                        resulting_string += input.charAt(parser_pos);\r\n                        if (!esc) {\r\n                            esc = input.charAt(parser_pos) === '\\\\';\r\n                            if (input.charAt(parser_pos) === '[') {\r\n                                in_char_class = true;\r\n                            } else if (input.charAt(parser_pos) === ']') {\r\n                                in_char_class = false;\r\n                            }\r\n                        } else {\r\n                            esc = false;\r\n                        }\r\n                        parser_pos += 1;\r\n                    }\r\n                } else if (opts.e4x && sep === '<') {\r\n                    //\r\n                    // handle e4x xml literals\r\n                    //\r\n                    var xmlRegExp = /<(\\/?)([-a-zA-Z:0-9_.]+|{[^{}]*}|!\\[CDATA\\[[\\s\\S]*?\\]\\])\\s*([-a-zA-Z:0-9_.]+=('[^']*'|\"[^\"]*\"|{[^{}]*})\\s*)*(\\/?)\\s*>/g;\r\n                    var xmlStr = input.slice(parser_pos - 1);\r\n                    var match = xmlRegExp.exec(xmlStr);\r\n                    if (match && match.index === 0) {\r\n                        var rootTag = match[2];\r\n                        var depth = 0;\r\n                        while (match) {\r\n                            var isEndTag = !! match[1];\r\n                            var tagName = match[2];\r\n                            var isSingletonTag = ( !! match[match.length - 1]) || (tagName.slice(0, 8) === \"![CDATA[\");\r\n                            if (tagName === rootTag && !isSingletonTag) {\r\n                                if (isEndTag) {\r\n                                    --depth;\r\n                                } else {\r\n                                    ++depth;\r\n                                }\r\n                            }\r\n                            if (depth <= 0) {\r\n                                break;\r\n                            }\r\n                            match = xmlRegExp.exec(xmlStr);\r\n                        }\r\n                        var xmlLength = match ? match.index + match[0].length : xmlStr.length;\r\n                        parser_pos += xmlLength - 1;\r\n                        return [xmlStr.slice(0, xmlLength), \"TK_STRING\"];\r\n                    }\r\n                } else {\r\n                    //\r\n                    // handle string\r\n                    //\r\n                    // Template strings can travers lines without escape characters.\r\n                    // Other strings cannot\r\n                    while (parser_pos < input_length &&\r\n                            (esc || (input.charAt(parser_pos) !== sep &&\r\n                            (sep === '`' || !acorn.newline.test(input.charAt(parser_pos)))))) {\r\n                        resulting_string += input.charAt(parser_pos);\r\n                        if (esc) {\r\n                            if (input.charAt(parser_pos) === 'x' || input.charAt(parser_pos) === 'u') {\r\n                                has_char_escapes = true;\r\n                            }\r\n                            esc = false;\r\n                        } else {\r\n                            esc = input.charAt(parser_pos) === '\\\\';\r\n                        }\r\n                        parser_pos += 1;\r\n                    }\r\n\r\n                }\r\n\r\n                if (has_char_escapes && opts.unescape_strings) {\r\n                    resulting_string = unescape_string(resulting_string);\r\n                }\r\n\r\n                if (parser_pos < input_length && input.charAt(parser_pos) === sep) {\r\n                    resulting_string += sep;\r\n                    parser_pos += 1;\r\n\r\n                    if (sep === '/') {\r\n                        // regexps may have modifiers /regexp/MOD , so fetch those, too\r\n                        // Only [gim] are valid, but if the user puts in garbage, do what we can to take it.\r\n                        while (parser_pos < input_length && acorn.isIdentifierStart(input.charCodeAt(parser_pos))) {\r\n                            resulting_string += input.charAt(parser_pos);\r\n                            parser_pos += 1;\r\n                        }\r\n                    }\r\n                }\r\n                return [resulting_string, 'TK_STRING'];\r\n            }\r\n\r\n            if (c === '#') {\r\n\r\n                if (tokens.length === 0 && input.charAt(parser_pos) === '!') {\r\n                    // shebang\r\n                    resulting_string = c;\r\n                    while (parser_pos < input_length && c !== '\\n') {\r\n                        c = input.charAt(parser_pos);\r\n                        resulting_string += c;\r\n                        parser_pos += 1;\r\n                    }\r\n                    return [trim(resulting_string) + '\\n', 'TK_UNKNOWN'];\r\n                }\r\n\r\n\r\n\r\n                // Spidermonkey-specific sharp variables for circular references\r\n                // https://developer.mozilla.org/En/Sharp_variables_in_JavaScript\r\n                // http://mxr.mozilla.org/mozilla-central/source/js/src/jsscan.cpp around line 1935\r\n                var sharp = '#';\r\n                if (parser_pos < input_length && digit.test(input.charAt(parser_pos))) {\r\n                    do {\r\n                        c = input.charAt(parser_pos);\r\n                        sharp += c;\r\n                        parser_pos += 1;\r\n                    } while (parser_pos < input_length && c !== '#' && c !== '=');\r\n                    if (c === '#') {\r\n                        //\r\n                    } else if (input.charAt(parser_pos) === '[' && input.charAt(parser_pos + 1) === ']') {\r\n                        sharp += '[]';\r\n                        parser_pos += 2;\r\n                    } else if (input.charAt(parser_pos) === '{' && input.charAt(parser_pos + 1) === '}') {\r\n                        sharp += '{}';\r\n                        parser_pos += 2;\r\n                    }\r\n                    return [sharp, 'TK_WORD'];\r\n                }\r\n            }\r\n\r\n            if (c === '<' && input.substring(parser_pos - 1, parser_pos + 3) === '<!--') {\r\n                parser_pos += 3;\r\n                c = '<!--';\r\n                while (input.charAt(parser_pos) !== '\\n' && parser_pos < input_length) {\r\n                    c += input.charAt(parser_pos);\r\n                    parser_pos++;\r\n                }\r\n                in_html_comment = true;\r\n                return [c, 'TK_COMMENT'];\r\n            }\r\n\r\n            if (c === '-' && in_html_comment && input.substring(parser_pos - 1, parser_pos + 2) === '-->') {\r\n                in_html_comment = false;\r\n                parser_pos += 2;\r\n                return ['-->', 'TK_COMMENT'];\r\n            }\r\n\r\n            if (c === '.') {\r\n                return [c, 'TK_DOT'];\r\n            }\r\n\r\n            if (in_array(c, punct)) {\r\n                while (parser_pos < input_length && in_array(c + input.charAt(parser_pos), punct)) {\r\n                    c += input.charAt(parser_pos);\r\n                    parser_pos += 1;\r\n                    if (parser_pos >= input_length) {\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (c === ',') {\r\n                    return [c, 'TK_COMMA'];\r\n                } else if (c === '=') {\r\n                    return [c, 'TK_EQUALS'];\r\n                } else {\r\n                    return [c, 'TK_OPERATOR'];\r\n                }\r\n            }\r\n\r\n            return [c, 'TK_UNKNOWN'];\r\n        }\r\n\r\n\r\n        function unescape_string(s) {\r\n            var esc = false,\r\n                out = '',\r\n                pos = 0,\r\n                s_hex = '',\r\n                escaped = 0,\r\n                c;\r\n\r\n            while (esc || pos < s.length) {\r\n\r\n                c = s.charAt(pos);\r\n                pos++;\r\n\r\n                if (esc) {\r\n                    esc = false;\r\n                    if (c === 'x') {\r\n                        // simple hex-escape \\x24\r\n                        s_hex = s.substr(pos, 2);\r\n                        pos += 2;\r\n                    } else if (c === 'u') {\r\n                        // unicode-escape, \\u2134\r\n                        s_hex = s.substr(pos, 4);\r\n                        pos += 4;\r\n                    } else {\r\n                        // some common escape, e.g \\n\r\n                        out += '\\\\' + c;\r\n                        continue;\r\n                    }\r\n                    if (!s_hex.match(/^[0123456789abcdefABCDEF]+$/)) {\r\n                        // some weird escaping, bail out,\r\n                        // leaving whole string intact\r\n                        return s;\r\n                    }\r\n\r\n                    escaped = parseInt(s_hex, 16);\r\n\r\n                    if (escaped >= 0x00 && escaped < 0x20) {\r\n                        // leave 0x00...0x1f escaped\r\n                        if (c === 'x') {\r\n                            out += '\\\\x' + s_hex;\r\n                        } else {\r\n                            out += '\\\\u' + s_hex;\r\n                        }\r\n                        continue;\r\n                    } else if (escaped === 0x22 || escaped === 0x27 || escaped === 0x5c) {\r\n                        // single-quote, apostrophe, backslash - escape these\r\n                        out += '\\\\' + String.fromCharCode(escaped);\r\n                    } else if (c === 'x' && escaped > 0x7e && escaped <= 0xff) {\r\n                        // we bail out on \\x7f..\\xff,\r\n                        // leaving whole string escaped,\r\n                        // as it's probably completely binary\r\n                        return s;\r\n                    } else {\r\n                        out += String.fromCharCode(escaped);\r\n                    }\r\n                } else if (c === '\\\\') {\r\n                    esc = true;\r\n                } else {\r\n                    out += c;\r\n                }\r\n            }\r\n            return out;\r\n        }\r\n\r\n    }\r\n\r\n    return { js_beautify: js_beautify };\r\n});\r\n\ndefine('skylark-utils-js/beautify',[\r\n    \"./js\",\r\n    \"./primitives/beautify-js\"\r\n], function(js, beautifyJs) {\r\n\r\n\treturn js.beautify = beautifyJs.js_beautify;\r\n});\n/*jshint curly:true, eqeqeq:true, laxbreak:true, noempty:false */\n/*\n\n  The MIT License (MIT)\n\n  Copyright (c) 2007-2013 Einar Lielmanis and contributors.\n\n  Permission is hereby granted, free of charge, to any person\n  obtaining a copy of this software and associated documentation files\n  (the \"Software\"), to deal in the Software without restriction,\n  including without limitation the rights to use, copy, modify, merge,\n  publish, distribute, sublicense, and/or sell copies of the Software,\n  and to permit persons to whom the Software is furnished to do so,\n  subject to the following conditions:\n\n  The above copyright notice and this permission notice shall be\n  included in all copies or substantial portions of the Software.\n\n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n  SOFTWARE.\n\n\n Style HTML\n---------------\n\n  Written by Nochum Sossonko, (nsossonko@hotmail.com)\n\n  Based on code initially developed by: Einar Lielmanis, <einar@jsbeautifier.org>\n    http://jsbeautifier.org/\n\n  Usage:\n    style_html(html_source);\n\n    style_html(html_source, options);\n\n  The options are:\n    indent_inner_html (default false)   indent <head> and <body> sections,\n    indent_size (default 4)           indentation size,\n    indent_char (default space)       character to indent with,\n    wrap_line_length (default 250)            -  maximum amount of characters per line (0 = disable)\n    brace_style (default \"collapse\") - \"collapse\" | \"expand\" | \"end-expand\" | \"none\"\n            put braces on the same line as control statements (default), or put braces on own line (Allman / ANSI style), or just put end braces on own line, or attempt to keep them where they are.\n    unformatted (defaults to inline tags) - list of tags, that shouldn't be reformatted\n    indent_scripts (default normal)  - \"keep\"|\"separate\"|\"normal\"\n    preserve_newlines (default true) - whether existing line breaks before elements should be preserved\n                                        Only works before elements, not inside tags or for text.\n    max_preserve_newlines (default unlimited) - maximum number of line breaks to be preserved in one chunk\n    indent_handlebars (default false) - format and indent {{#foo}} and {{/foo}}\n    end_with_newline (false)          - end with a newline\n\n\n    e.g.\n\n    style_html(html_source, {\n      'indent_inner_html': false,\n      'indent_size': 2,\n      'indent_char': ' ',\n      'wrap_line_length': 78,\n      'brace_style': 'expand',\n      'unformatted': ['a', 'sub', 'sup', 'b', 'i', 'u'],\n      'preserve_newlines': true,\n      'max_preserve_newlines': 5,\n      'indent_handlebars': false\n    });\n*/\n\ndefine('skylark-utils-html/primitives/beautify-html',[\n    \"skylark-utils-css/beautify\",\n    \"skylark-utils-js/beautify\"\n], function(beautifyCss, beautifyHtml) {\n\n    function trim(s) {\n        return s.replace(/^\\s+|\\s+$/g, '');\n    }\n\n    function ltrim(s) {\n        return s.replace(/^\\s+/g, '');\n    }\n\n    function rtrim(s) {\n        return s.replace(/\\s+$/g,'');\n    }\n\n    function style_html(html_source, options, js_beautify, css_beautify) {\n        //Wrapper function to invoke all the necessary constructors and deal with the output.\n\n        var multi_parser,\n            indent_inner_html,\n            indent_size,\n            indent_character,\n            wrap_line_length,\n            brace_style,\n            unformatted,\n            preserve_newlines,\n            max_preserve_newlines,\n            indent_handlebars,\n            end_with_newline;\n\n        options = options || {};\n\n        // backwards compatibility to 1.3.4\n        if ((options.wrap_line_length === undefined || parseInt(options.wrap_line_length, 10) === 0) &&\n                (options.max_char !== undefined && parseInt(options.max_char, 10) !== 0)) {\n            options.wrap_line_length = options.max_char;\n        }\n\n        indent_inner_html = (options.indent_inner_html === undefined) ? false : options.indent_inner_html;\n        indent_size = (options.indent_size === undefined) ? 4 : parseInt(options.indent_size, 10);\n        indent_character = (options.indent_char === undefined) ? ' ' : options.indent_char;\n        brace_style = (options.brace_style === undefined) ? 'collapse' : options.brace_style;\n        wrap_line_length =  parseInt(options.wrap_line_length, 10) === 0 ? 32786 : parseInt(options.wrap_line_length || 250, 10);\n        unformatted = options.unformatted || ['a', 'span', 'img', 'bdo', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'q', 'sub', 'sup', 'tt', 'i', 'b', 'big', 'small', 'u', 's', 'strike', 'font', 'ins', 'del', 'pre', 'address', 'dt', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'];\n        preserve_newlines = (options.preserve_newlines === undefined) ? true : options.preserve_newlines;\n        max_preserve_newlines = preserve_newlines ?\n            (isNaN(parseInt(options.max_preserve_newlines, 10)) ? 32786 : parseInt(options.max_preserve_newlines, 10))\n            : 0;\n        indent_handlebars = (options.indent_handlebars === undefined) ? false : options.indent_handlebars;\n        end_with_newline = (options.end_with_newline === undefined) ? false : options.end_with_newline;\n\n        function Parser() {\n\n            this.pos = 0; //Parser position\n            this.token = '';\n            this.current_mode = 'CONTENT'; //reflects the current Parser mode: TAG/CONTENT\n            this.tags = { //An object to hold tags, their position, and their parent-tags, initiated with default values\n                parent: 'parent1',\n                parentcount: 1,\n                parent1: ''\n            };\n            this.tag_type = '';\n            this.token_text = this.last_token = this.last_text = this.token_type = '';\n            this.newlines = 0;\n            this.indent_content = indent_inner_html;\n\n            this.Utils = { //Uilities made available to the various functions\n                whitespace: \"\\n\\r\\t \".split(''),\n                single_token: 'br,input,link,meta,!doctype,basefont,base,area,hr,wbr,param,img,isindex,?xml,embed,?php,?,?='.split(','), //all the single tags for HTML\n                extra_liners: 'head,body,/html'.split(','), //for tags that need a line of whitespace before them\n                in_array: function(what, arr) {\n                    for (var i = 0; i < arr.length; i++) {\n                        if (what === arr[i]) {\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n            };\n\n            // Return true iff the given text is composed entirely of\n            // whitespace.\n            this.is_whitespace = function(text) {\n                for (var n = 0; n < text.length; text++) {\n                    if (!this.Utils.in_array(text.charAt(n), this.Utils.whitespace)) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            this.traverse_whitespace = function() {\n                var input_char = '';\n\n                input_char = this.input.charAt(this.pos);\n                if (this.Utils.in_array(input_char, this.Utils.whitespace)) {\n                    this.newlines = 0;\n                    while (this.Utils.in_array(input_char, this.Utils.whitespace)) {\n                        if (preserve_newlines && input_char === '\\n' && this.newlines <= max_preserve_newlines) {\n                            this.newlines += 1;\n                        }\n\n                        this.pos++;\n                        input_char = this.input.charAt(this.pos);\n                    }\n                    return true;\n                }\n                return false;\n            };\n\n            // Append a space to the given content (string array) or, if we are\n            // at the wrap_line_length, append a newline/indentation.\n            this.space_or_wrap = function(content) {\n                if (this.line_char_count >= this.wrap_line_length) { //insert a line when the wrap_line_length is reached\n                    this.print_newline(false, content);\n                    this.print_indentation(content);\n                } else {\n                    this.line_char_count++;\n                    content.push(' ');\n                }\n            };\n\n            this.get_content = function() { //function to capture regular content between tags\n                var input_char = '',\n                    content = [],\n                    space = false; //if a space is needed\n\n                while (this.input.charAt(this.pos) !== '<') {\n                    if (this.pos >= this.input.length) {\n                        return content.length ? content.join('') : ['', 'TK_EOF'];\n                    }\n\n                    if (this.traverse_whitespace()) {\n                        this.space_or_wrap(content);\n                        continue;\n                    }\n\n                    if (indent_handlebars) {\n                        // Handlebars parsing is complicated.\n                        // {{#foo}} and {{/foo}} are formatted tags.\n                        // {{something}} should get treated as content, except:\n                        // {{else}} specifically behaves like {{#if}} and {{/if}}\n                        var peek3 = this.input.substr(this.pos, 3);\n                        if (peek3 === '{{#' || peek3 === '{{/') {\n                            // These are tags and not content.\n                            break;\n                        } else if (this.input.substr(this.pos, 2) === '{{') {\n                            if (this.get_tag(true) === '{{else}}') {\n                                break;\n                            }\n                        }\n                    }\n\n                    input_char = this.input.charAt(this.pos);\n                    this.pos++;\n                    this.line_char_count++;\n                    content.push(input_char); //letter at-a-time (or string) inserted to an array\n                }\n                return content.length ? content.join('') : '';\n            };\n\n            this.get_contents_to = function(name) { //get the full content of a script or style to pass to js_beautify\n                if (this.pos === this.input.length) {\n                    return ['', 'TK_EOF'];\n                }\n                var input_char = '';\n                var content = '';\n                var reg_match = new RegExp('</' + name + '\\\\s*>', 'igm');\n                reg_match.lastIndex = this.pos;\n                var reg_array = reg_match.exec(this.input);\n                var end_script = reg_array ? reg_array.index : this.input.length; //absolute end of script\n                if (this.pos < end_script) { //get everything in between the script tags\n                    content = this.input.substring(this.pos, end_script);\n                    this.pos = end_script;\n                }\n                return content;\n            };\n\n            this.record_tag = function(tag) { //function to record a tag and its parent in this.tags Object\n                if (this.tags[tag + 'count']) { //check for the existence of this tag type\n                    this.tags[tag + 'count']++;\n                    this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level\n                } else { //otherwise initialize this tag type\n                    this.tags[tag + 'count'] = 1;\n                    this.tags[tag + this.tags[tag + 'count']] = this.indent_level; //and record the present indent level\n                }\n                this.tags[tag + this.tags[tag + 'count'] + 'parent'] = this.tags.parent; //set the parent (i.e. in the case of a div this.tags.div1parent)\n                this.tags.parent = tag + this.tags[tag + 'count']; //and make this the current parent (i.e. in the case of a div 'div1')\n            };\n\n            this.retrieve_tag = function(tag) { //function to retrieve the opening tag to the corresponding closer\n                if (this.tags[tag + 'count']) { //if the openener is not in the Object we ignore it\n                    var temp_parent = this.tags.parent; //check to see if it's a closable tag.\n                    while (temp_parent) { //till we reach '' (the initial value);\n                        if (tag + this.tags[tag + 'count'] === temp_parent) { //if this is it use it\n                            break;\n                        }\n                        temp_parent = this.tags[temp_parent + 'parent']; //otherwise keep on climbing up the DOM Tree\n                    }\n                    if (temp_parent) { //if we caught something\n                        this.indent_level = this.tags[tag + this.tags[tag + 'count']]; //set the indent_level accordingly\n                        this.tags.parent = this.tags[temp_parent + 'parent']; //and set the current parent\n                    }\n                    delete this.tags[tag + this.tags[tag + 'count'] + 'parent']; //delete the closed tags parent reference...\n                    delete this.tags[tag + this.tags[tag + 'count']]; //...and the tag itself\n                    if (this.tags[tag + 'count'] === 1) {\n                        delete this.tags[tag + 'count'];\n                    } else {\n                        this.tags[tag + 'count']--;\n                    }\n                }\n            };\n\n            this.indent_to_tag = function(tag) {\n                // Match the indentation level to the last use of this tag, but don't remove it.\n                if (!this.tags[tag + 'count']) {\n                    return;\n                }\n                var temp_parent = this.tags.parent;\n                while (temp_parent) {\n                    if (tag + this.tags[tag + 'count'] === temp_parent) {\n                        break;\n                    }\n                    temp_parent = this.tags[temp_parent + 'parent'];\n                }\n                if (temp_parent) {\n                    this.indent_level = this.tags[tag + this.tags[tag + 'count']];\n                }\n            };\n\n            this.get_tag = function(peek) { //function to get a full tag and parse its type\n                var input_char = '',\n                    content = [],\n                    comment = '',\n                    space = false,\n                    tag_start, tag_end,\n                    tag_start_char,\n                    orig_pos = this.pos,\n                    orig_line_char_count = this.line_char_count;\n\n                peek = peek !== undefined ? peek : false;\n\n                do {\n                    if (this.pos >= this.input.length) {\n                        if (peek) {\n                            this.pos = orig_pos;\n                            this.line_char_count = orig_line_char_count;\n                        }\n                        return content.length ? content.join('') : ['', 'TK_EOF'];\n                    }\n\n                    input_char = this.input.charAt(this.pos);\n                    this.pos++;\n\n                    if (this.Utils.in_array(input_char, this.Utils.whitespace)) { //don't want to insert unnecessary space\n                        space = true;\n                        continue;\n                    }\n\n                    if (input_char === \"'\" || input_char === '\"') {\n                        input_char += this.get_unformatted(input_char);\n                        space = true;\n\n                    }\n\n                    if (input_char === '=') { //no space before =\n                        space = false;\n                    }\n\n                    if (content.length && content[content.length - 1] !== '=' && input_char !== '>' && space) {\n                        //no space after = or before >\n                        this.space_or_wrap(content);\n                        space = false;\n                    }\n\n                    if (indent_handlebars && tag_start_char === '<') {\n                        // When inside an angle-bracket tag, put spaces around\n                        // handlebars not inside of strings.\n                        if ((input_char + this.input.charAt(this.pos)) === '{{') {\n                            input_char += this.get_unformatted('}}');\n                            if (content.length && content[content.length - 1] !== ' ' && content[content.length - 1] !== '<') {\n                                input_char = ' ' + input_char;\n                            }\n                            space = true;\n                        }\n                    }\n\n                    if (input_char === '<' && !tag_start_char) {\n                        tag_start = this.pos - 1;\n                        tag_start_char = '<';\n                    }\n\n                    if (indent_handlebars && !tag_start_char) {\n                        if (content.length >= 2 && content[content.length - 1] === '{' && content[content.length - 2] == '{') {\n                            if (input_char === '#' || input_char === '/') {\n                                tag_start = this.pos - 3;\n                            } else {\n                                tag_start = this.pos - 2;\n                            }\n                            tag_start_char = '{';\n                        }\n                    }\n\n                    this.line_char_count++;\n                    content.push(input_char); //inserts character at-a-time (or string)\n\n                    if (content[1] && content[1] === '!') { //if we're in a comment, do something special\n                        // We treat all comments as literals, even more than preformatted tags\n                        // we just look for the appropriate close tag\n                        content = [this.get_comment(tag_start)];\n                        break;\n                    }\n\n                    if (indent_handlebars && tag_start_char === '{' && content.length > 2 && content[content.length - 2] === '}' && content[content.length - 1] === '}') {\n                        break;\n                    }\n                } while (input_char !== '>');\n\n                var tag_complete = content.join('');\n                var tag_index;\n                var tag_offset;\n\n                if (tag_complete.indexOf(' ') !== -1) { //if there's whitespace, thats where the tag name ends\n                    tag_index = tag_complete.indexOf(' ');\n                } else if (tag_complete[0] === '{') {\n                    tag_index = tag_complete.indexOf('}');\n                } else { //otherwise go with the tag ending\n                    tag_index = tag_complete.indexOf('>');\n                }\n                if (tag_complete[0] === '<' || !indent_handlebars) {\n                    tag_offset = 1;\n                } else {\n                    tag_offset = tag_complete[2] === '#' ? 3 : 2;\n                }\n                var tag_check = tag_complete.substring(tag_offset, tag_index).toLowerCase();\n                if (tag_complete.charAt(tag_complete.length - 2) === '/' ||\n                    this.Utils.in_array(tag_check, this.Utils.single_token)) { //if this tag name is a single tag type (either in the list or has a closing /)\n                    if (!peek) {\n                        this.tag_type = 'SINGLE';\n                    }\n                } else if (indent_handlebars && tag_complete[0] === '{' && tag_check === 'else') {\n                    if (!peek) {\n                        this.indent_to_tag('if');\n                        this.tag_type = 'HANDLEBARS_ELSE';\n                        this.indent_content = true;\n                        this.traverse_whitespace();\n                    }\n                } else if (this.is_unformatted(tag_check, unformatted)) { // do not reformat the \"unformatted\" tags\n                    comment = this.get_unformatted('</' + tag_check + '>', tag_complete); //...delegate to get_unformatted function\n                    content.push(comment);\n                    tag_end = this.pos - 1;\n                    this.tag_type = 'SINGLE';\n                } else if (tag_check === 'script' &&\n                    (tag_complete.search('type') === -1 ||\n                    (tag_complete.search('type') > -1 &&\n                    tag_complete.search(/\\b(text|application)\\/(x-)?(javascript|ecmascript|jscript|livescript)/) > -1))) {\n                    if (!peek) {\n                        this.record_tag(tag_check);\n                        this.tag_type = 'SCRIPT';\n                    }\n                } else if (tag_check === 'style' &&\n                    (tag_complete.search('type') === -1 ||\n                    (tag_complete.search('type') > -1 && tag_complete.search('text/css') > -1))) {\n                    if (!peek) {\n                        this.record_tag(tag_check);\n                        this.tag_type = 'STYLE';\n                    }\n                } else if (tag_check.charAt(0) === '!') { //peek for <! comment\n                    // for comments content is already correct.\n                    if (!peek) {\n                        this.tag_type = 'SINGLE';\n                        this.traverse_whitespace();\n                    }\n                } else if (!peek) {\n                    if (tag_check.charAt(0) === '/') { //this tag is a double tag so check for tag-ending\n                        this.retrieve_tag(tag_check.substring(1)); //remove it and all ancestors\n                        this.tag_type = 'END';\n                    } else { //otherwise it's a start-tag\n                        this.record_tag(tag_check); //push it on the tag stack\n                        if (tag_check.toLowerCase() !== 'html') {\n                            this.indent_content = true;\n                        }\n                        this.tag_type = 'START';\n                    }\n\n                    // Allow preserving of newlines after a start or end tag\n                    if (this.traverse_whitespace()) {\n                        this.space_or_wrap(content);\n                    }\n\n                    if (this.Utils.in_array(tag_check, this.Utils.extra_liners)) { //check if this double needs an extra line\n                        this.print_newline(false, this.output);\n                        if (this.output.length && this.output[this.output.length - 2] !== '\\n') {\n                            this.print_newline(true, this.output);\n                        }\n                    }\n                }\n\n                if (peek) {\n                    this.pos = orig_pos;\n                    this.line_char_count = orig_line_char_count;\n                }\n\n                return content.join(''); //returns fully formatted tag\n            };\n\n            this.get_comment = function(start_pos) { //function to return comment content in its entirety\n                // this is will have very poor perf, but will work for now.\n                var comment = '',\n                    delimiter = '>',\n                    matched = false;\n\n                this.pos = start_pos;\n                input_char = this.input.charAt(this.pos);\n                this.pos++;\n\n                while (this.pos <= this.input.length) {\n                    comment += input_char;\n\n                    // only need to check for the delimiter if the last chars match\n                    if (comment[comment.length - 1] === delimiter[delimiter.length - 1] &&\n                        comment.indexOf(delimiter) !== -1) {\n                        break;\n                    }\n\n                    // only need to search for custom delimiter for the first few characters\n                    if (!matched && comment.length < 10) {\n                        if (comment.indexOf('<![if') === 0) { //peek for <![if conditional comment\n                            delimiter = '<![endif]>';\n                            matched = true;\n                        } else if (comment.indexOf('<![cdata[') === 0) { //if it's a <[cdata[ comment...\n                            delimiter = ']]>';\n                            matched = true;\n                        } else if (comment.indexOf('<![') === 0) { // some other ![ comment? ...\n                            delimiter = ']>';\n                            matched = true;\n                        } else if (comment.indexOf('<!--') === 0) { // <!-- comment ...\n                            delimiter = '-->';\n                            matched = true;\n                        }\n                    }\n\n                    input_char = this.input.charAt(this.pos);\n                    this.pos++;\n                }\n\n                return comment;\n            };\n\n            this.get_unformatted = function(delimiter, orig_tag) { //function to return unformatted content in its entirety\n\n                if (orig_tag && orig_tag.toLowerCase().indexOf(delimiter) !== -1) {\n                    return '';\n                }\n                var input_char = '';\n                var content = '';\n                var min_index = 0;\n                var space = true;\n                do {\n\n                    if (this.pos >= this.input.length) {\n                        return content;\n                    }\n\n                    input_char = this.input.charAt(this.pos);\n                    this.pos++;\n\n                    if (this.Utils.in_array(input_char, this.Utils.whitespace)) {\n                        if (!space) {\n                            this.line_char_count--;\n                            continue;\n                        }\n                        if (input_char === '\\n' || input_char === '\\r') {\n                            content += '\\n';\n                            /*  Don't change tab indention for unformatted blocks.  If using code for html editing, this will greatly affect <pre> tags if they are specified in the 'unformatted array'\n                for (var i=0; i<this.indent_level; i++) {\n                  content += this.indent_string;\n                }\n                space = false; //...and make sure other indentation is erased\n                */\n                            this.line_char_count = 0;\n                            continue;\n                        }\n                    }\n                    content += input_char;\n                    this.line_char_count++;\n                    space = true;\n\n                    if (indent_handlebars && input_char === '{' && content.length && content[content.length - 2] === '{') {\n                        // Handlebars expressions in strings should also be unformatted.\n                        content += this.get_unformatted('}}');\n                        // These expressions are opaque.  Ignore delimiters found in them.\n                        min_index = content.length;\n                    }\n                } while (content.toLowerCase().indexOf(delimiter, min_index) === -1);\n                return content;\n            };\n\n            this.get_token = function() { //initial handler for token-retrieval\n                var token;\n\n                if (this.last_token === 'TK_TAG_SCRIPT' || this.last_token === 'TK_TAG_STYLE') { //check if we need to format javascript\n                    var type = this.last_token.substr(7);\n                    token = this.get_contents_to(type);\n                    if (typeof token !== 'string') {\n                        return token;\n                    }\n                    return [token, 'TK_' + type];\n                }\n                if (this.current_mode === 'CONTENT') {\n                    token = this.get_content();\n                    if (typeof token !== 'string') {\n                        return token;\n                    } else {\n                        return [token, 'TK_CONTENT'];\n                    }\n                }\n\n                if (this.current_mode === 'TAG') {\n                    token = this.get_tag();\n                    if (typeof token !== 'string') {\n                        return token;\n                    } else {\n                        var tag_name_type = 'TK_TAG_' + this.tag_type;\n                        return [token, tag_name_type];\n                    }\n                }\n            };\n\n            this.get_full_indent = function(level) {\n                level = this.indent_level + level || 0;\n                if (level < 1) {\n                    return '';\n                }\n\n                return Array(level + 1).join(this.indent_string);\n            };\n\n            this.is_unformatted = function(tag_check, unformatted) {\n                //is this an HTML5 block-level link?\n                if (!this.Utils.in_array(tag_check, unformatted)) {\n                    return false;\n                }\n\n                if (tag_check.toLowerCase() !== 'a' || !this.Utils.in_array('a', unformatted)) {\n                    return true;\n                }\n\n                //at this point we have an  tag; is its first child something we want to remain\n                //unformatted?\n                var next_tag = this.get_tag(true /* peek. */ );\n\n                // test next_tag to see if it is just html tag (no external content)\n                var tag = (next_tag || \"\").match(/^\\s*<\\s*\\/?([a-z]*)\\s*[^>]*>\\s*$/);\n\n                // if next_tag comes back but is not an isolated tag, then\n                // let's treat the 'a' tag as having content\n                // and respect the unformatted option\n                if (!tag || this.Utils.in_array(tag, unformatted)) {\n                    return true;\n                } else {\n                    return false;\n                }\n            };\n\n            this.printer = function(js_source, indent_character, indent_size, wrap_line_length, brace_style) { //handles input/output and some other printing functions\n\n                this.input = js_source || ''; //gets the input for the Parser\n                this.output = [];\n                this.indent_character = indent_character;\n                this.indent_string = '';\n                this.indent_size = indent_size;\n                this.brace_style = brace_style;\n                this.indent_level = 0;\n                this.wrap_line_length = wrap_line_length;\n                this.line_char_count = 0; //count to see if wrap_line_length was exceeded\n\n                for (var i = 0; i < this.indent_size; i++) {\n                    this.indent_string += this.indent_character;\n                }\n\n                this.print_newline = function(force, arr) {\n                    this.line_char_count = 0;\n                    if (!arr || !arr.length) {\n                        return;\n                    }\n                    if (force || (arr[arr.length - 1] !== '\\n')) { //we might want the extra line\n                        if ((arr[arr.length - 1] !== '\\n')) {\n                            arr[arr.length - 1] = rtrim(arr[arr.length - 1]);\n                        }\n                        arr.push('\\n');\n                    }\n                };\n\n                this.print_indentation = function(arr) {\n                    for (var i = 0; i < this.indent_level; i++) {\n                        arr.push(this.indent_string);\n                        this.line_char_count += this.indent_string.length;\n                    }\n                };\n\n                this.print_token = function(text) {\n                    // Avoid printing initial whitespace.\n                    if (this.is_whitespace(text) && !this.output.length) {\n                        return;\n                    }\n                    if (text || text !== '') {\n                        if (this.output.length && this.output[this.output.length - 1] === '\\n') {\n                            this.print_indentation(this.output);\n                            text = ltrim(text);\n                        }\n                    }\n                    this.print_token_raw(text);\n                };\n\n                this.print_token_raw = function(text) {\n                    // If we are going to print newlines, truncate trailing\n                    // whitespace, as the newlines will represent the space.\n                    if (this.newlines > 0) {\n                        text = rtrim(text);\n                    }\n\n                    if (text && text !== '') {\n                        if (text.length > 1 && text[text.length - 1] === '\\n') {\n                            // unformatted tags can grab newlines as their last character\n                            this.output.push(text.slice(0, -1));\n                            this.print_newline(false, this.output);\n                        } else {\n                            this.output.push(text);\n                        }\n                    }\n\n                    for (var n = 0; n < this.newlines; n++) {\n                        this.print_newline(n > 0, this.output);\n                    }\n                    this.newlines = 0;\n                };\n\n                this.indent = function() {\n                    this.indent_level++;\n                };\n\n                this.unindent = function() {\n                    if (this.indent_level > 0) {\n                        this.indent_level--;\n                    }\n                };\n            };\n            return this;\n        }\n\n        /*_____________________--------------------_____________________*/\n\n        multi_parser = new Parser(); //wrapping functions Parser\n        multi_parser.printer(html_source, indent_character, indent_size, wrap_line_length, brace_style); //initialize starting values\n\n        while (true) {\n            var t = multi_parser.get_token();\n            multi_parser.token_text = t[0];\n            multi_parser.token_type = t[1];\n\n            if (multi_parser.token_type === 'TK_EOF') {\n                break;\n            }\n\n            switch (multi_parser.token_type) {\n                case 'TK_TAG_START':\n                    multi_parser.print_newline(false, multi_parser.output);\n                    multi_parser.print_token(multi_parser.token_text);\n                    if (multi_parser.indent_content) {\n                        multi_parser.indent();\n                        multi_parser.indent_content = false;\n                    }\n                    multi_parser.current_mode = 'CONTENT';\n                    break;\n                case 'TK_TAG_STYLE':\n                case 'TK_TAG_SCRIPT':\n                    multi_parser.print_newline(false, multi_parser.output);\n                    multi_parser.print_token(multi_parser.token_text);\n                    multi_parser.current_mode = 'CONTENT';\n                    break;\n                case 'TK_TAG_END':\n                    //Print new line only if the tag has no content and has child\n                    if (multi_parser.last_token === 'TK_CONTENT' && multi_parser.last_text === '') {\n                        var tag_name = multi_parser.token_text.match(/\\w+/)[0];\n                        var tag_extracted_from_last_output = null;\n                        if (multi_parser.output.length) {\n                            tag_extracted_from_last_output = multi_parser.output[multi_parser.output.length - 1].match(/(?:<|{{#)\\s*(\\w+)/);\n                        }\n                        if (tag_extracted_from_last_output === null ||\n                            tag_extracted_from_last_output[1] !== tag_name) {\n                            multi_parser.print_newline(false, multi_parser.output);\n                        }\n                    }\n                    multi_parser.print_token(multi_parser.token_text);\n                    multi_parser.current_mode = 'CONTENT';\n                    break;\n                case 'TK_TAG_SINGLE':\n                    // Don't add a newline before elements that should remain unformatted.\n                    var tag_check = multi_parser.token_text.match(/^\\s*<([a-z-]+)/i);\n                    if (!tag_check || !multi_parser.Utils.in_array(tag_check[1], unformatted)) {\n                        multi_parser.print_newline(false, multi_parser.output);\n                    }\n                    multi_parser.print_token(multi_parser.token_text);\n                    multi_parser.current_mode = 'CONTENT';\n                    break;\n                case 'TK_TAG_HANDLEBARS_ELSE':\n                    multi_parser.print_token(multi_parser.token_text);\n                    if (multi_parser.indent_content) {\n                        multi_parser.indent();\n                        multi_parser.indent_content = false;\n                    }\n                    multi_parser.current_mode = 'CONTENT';\n                    break;\n                case 'TK_CONTENT':\n                    multi_parser.print_token(multi_parser.token_text);\n                    multi_parser.current_mode = 'TAG';\n                    break;\n                case 'TK_STYLE':\n                case 'TK_SCRIPT':\n                    if (multi_parser.token_text !== '') {\n                        multi_parser.print_newline(false, multi_parser.output);\n                        var text = multi_parser.token_text,\n                            _beautifier,\n                            script_indent_level = 1;\n                        if (multi_parser.token_type === 'TK_SCRIPT') {\n                            _beautifier = typeof js_beautify === 'function' && js_beautify;\n                        } else if (multi_parser.token_type === 'TK_STYLE') {\n                            _beautifier = typeof css_beautify === 'function' && css_beautify;\n                        }\n\n                        if (options.indent_scripts === \"keep\") {\n                            script_indent_level = 0;\n                        } else if (options.indent_scripts === \"separate\") {\n                            script_indent_level = -multi_parser.indent_level;\n                        }\n\n                        var indentation = multi_parser.get_full_indent(script_indent_level);\n                        if (_beautifier) {\n                            // call the Beautifier if avaliable\n                            text = _beautifier(text.replace(/^\\s*/, indentation), options);\n                        } else {\n                            // simply indent the string otherwise\n                            var white = text.match(/^\\s*/)[0];\n                            var _level = white.match(/[^\\n\\r]*$/)[0].split(multi_parser.indent_string).length - 1;\n                            var reindent = multi_parser.get_full_indent(script_indent_level - _level);\n                            text = text.replace(/^\\s*/, indentation)\n                                .replace(/\\r\\n|\\r|\\n/g, '\\n' + reindent)\n                                .replace(/\\s+$/, '');\n                        }\n                        if (text) {\n                            multi_parser.print_token_raw(text);\n                            multi_parser.print_newline(true, multi_parser.output);\n                        }\n                    }\n                    multi_parser.current_mode = 'TAG';\n                    break;\n                default:\n                    // We should not be getting here but we don't want to drop input on the floor\n                    // Just output the text and move on\n                    if (multi_parser.token_text !== '') {\n                        multi_parser.print_token(multi_parser.token_text);\n                    }\n                    break;\n            }\n            multi_parser.last_token = multi_parser.token_type;\n            multi_parser.last_text = multi_parser.token_text;\n        }\n        var sweet_code = multi_parser.output.join('').replace(/[\\r\\n\\t ]+$/, '');\n        if (end_with_newline) {\n            sweet_code += '\\n';\n        }\n        return sweet_code;\n    }\n\n\n    return {\n      html_beautify: function(html_source, options) {\n        return style_html(html_source, options, beautifyJs, beautifyCss);\n      }\n    };\n\n});\n\ndefine('skylark-utils-html/beautify',[\r\n    \"./html\",\r\n    \"./primitives/beautify-html\"\r\n], function(html, beautifyHtml) {\r\n\r\n\treturn html.beautify = beautifyHtml.html_beautify;\r\n});\ndefine('skylark-utils-html/main',[\r\n    \"./html\",\r\n    \"./beautify\"\r\n], function(html) {\r\n    return html;\r\n});\r\n\ndefine('skylark-utils-html', ['skylark-utils-html/main'], function (main) { return main; });\n\n"]}